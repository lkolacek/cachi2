{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hermeto","text":"<p>Hermeto is a CLI tool that pre-fetches your project's dependencies to aid in making your build process hermetic.</p> <p>To see if we support your package manager(s), please check the package managers section.</p> <p>The primary intended use of Hermeto's outputs is for network-isolated container builds.</p>"},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>Goals</li> <li>Installation</li> <li>Basic usage</li> <li>Configuration</li> <li>Package managers</li> <li>Project status</li> </ul>"},{"location":"#goals","title":"Goals","text":"<p>Please note that Hermeto is rather picky, aiming to:</p> <ul> <li>encourage or enforce best practices</li> <li>never execute arbitrary code <sup>1</sup></li> <li>keep the implementation simple</li> </ul> <p>To play nicely with Hermeto, the build process for your project must be</p> <ul> <li>Defined - Hermeto only fetches dependencies that are explicitly declared - typically in a lockfile generated by   your package manager.</li> <li>Reproducible - Hermeto will refuse to fetch a dependency if it's not pinned to an exact version. This goes   for transitive dependencies as well (and ties to the Defined point). Most package managers pin all dependencies   automatically in lockfiles.</li> <li>Secure - Even with a lockfile, your build is not truly safe from supply chain attacks   unless you verify the checksums of all dependencies. If your package manager supports specifying   the expected checksums, we strongly encourage you to make use of them.</li> </ul> <p>\u26a0 Hermeto will verify checksums if present, but doesn't require them by default. This may change in the future.</p> <p>In return, Hermeto will help make your build</p> <ul> <li>Auditable - by generating a manifest of all the dependencies that go into your build.</li> </ul> <p>The ability to achieve the goals depends on the hermeticity of the build process. Ideally, you should try to isolate the build from both the internet and the underlying host system to avoid implicit dependencies, irreproducible behavior and whole hosts of other issues. Hermeto itself is not a hermetic build system. We suggest you take advantage of existing technologies - such as containers - to achieve network isolation.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#standalone","title":"Standalone","text":"<p>We do not distribute Hermeto as a standalone package as of now.</p> <p>To install Hermeto for local development, see the CONTRIBUTING.md.</p>"},{"location":"#container-image","title":"Container image","text":"<pre><code>quay.io/konflux-ci/hermeto:latest\n</code></pre> <p>The container is re-built automatically on every merge to the main branch.</p> <p>You may wish to set up an alias to make local usage more convenient:</p> <pre><code>alias hermeto='podman run --rm -ti -v \"$PWD:$PWD:z\" -w \"$PWD\" quay.io/konflux-ci/hermeto:latest'\n</code></pre> <p>Note that the alias mounts the current working directory - the container will have access to files in that directory and nowhere else.</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  --sbom-output-type cyclonedx \\\n  gomod\n</code></pre> <p>The <code>fetch-deps</code> command fetches your project's dependencies and stores them on your disk. Hermeto also produces a detailed SBOM containing information about all the project's components and packages. You can find the SBOM in the output directory.</p> <p>See <code>docs/usage.md</code> for a more detailed, practical example of Hermeto usage.</p> <p>You might also like to check out <code>hermeto --help</code> and the <code>--help</code> texts of the available subcommands.</p>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#modes","title":"Modes","text":"<p>Hermeto can be run in two modes using the global CLI option <code>--mode</code>.</p> <ul> <li>strict</li> <li>permissive</li> </ul> <p>The default mode is <code>strict</code>. In this mode, some input requirements that are not met are treated as errors. On the other hand, the <code>permissive</code> mode treats them as warnings. This means that Hermeto will proceed and generate an SBOM, but it may not be complete or accurate. The permissive mode can currently suppress the following: * go <code>vendor</code> directory inconsistencies (See <code>docs/gomod.md</code> on vendoring information)</p>"},{"location":"#available-configuration-parameters","title":"Available configuration parameters","text":"<p>You can change Hermeto's configuration by specifying a configuration file while invoking any of the CLI commands:</p> <pre><code> hermeto --config-file config.yaml fetch-deps --source ./my-repo gomod\n</code></pre> <p>Any parameter specified in this file will override the default values present in the config.py module.</p> <p>The only supported format for the config file is YAML.</p> <ul> <li><code>default_environment_variables</code> - a dictionary where the keys are names of package managers. The values are dictionaries where the keys are default environment variables to set for that package manager and the values are the environment variable values.</li> <li><code>gomod_download_max_tries</code> - a maximum number of attempts for retrying go commands.</li> <li><code>gomod_strict_vendor</code> - (deprecated) the bool to disable/enable the strict vendor mode. For a repo that has gomod dependencies, if the <code>vendor</code> directory exists and this config option is set to <code>True</code>, one of the vendoring flags must be used. This option no longer has any effect when set.</li> <li><code>goproxy_url</code> - sets the value of the GOPROXY variable that Hermeto uses internally when downloading Go modules. See Go environment variables.</li> <li><code>requests_timeout</code> - a number (in seconds) for <code>requests.get()</code>'s 'timeout' parameter,   which sets an upper limit on how long <code>requests</code> can take to make a connection and/or send a response.   Larger numbers set longer timeouts.</li> <li><code>subprocess_timeout</code> - a number (in seconds) to set a timeout for commands executed by   the <code>subprocess</code> module. Set a larger number to give the subprocess execution more time.</li> </ul>"},{"location":"#package-managers","title":"Package managers","text":"Package manager Ecosystem bundler Ruby cargo Rust generic N/A gomod Go npm JavaScript pip Python rpm* RPM yarn JavaScript <p>*Currently, rpm is not fully supported. Therefore, we do not have documentation for it.</p>"},{"location":"#bundler","title":"bundler","text":"<p>https://bundler.io/</p> <p>Hermeto supports bundler by parsing the Gemfile.lock file present in the source repository and downloading the declared dependencies.</p> <p>To generate a lockfile or to make sure the file is up to date, you can use for example the <code>bundle lock</code> command, which generates the <code>Gemfile.lock</code> file based on the dependencies specified in the Gemfile. Both files must be present in the source repository so you should check them into your git repository.</p> <p>See <code>docs/bundler.md</code> for more details.</p>"},{"location":"#cargo","title":"cargo","text":"<p>https://doc.rust-lang.org/cargo/</p> <p>Hermeto supports Cargo by invoking the Cargo CLI to fetch Rust dependencies as declared in your project, ensuring reproducible builds with explicitly defined versions. Make sure to have up-to-date Cargo.lock present in your project.</p> <p>See <code>docs/cargo.md</code> for more details.</p>"},{"location":"#generic-fetcher","title":"generic fetcher","text":"<p>Generic fetcher is a way for Hermeto to support prefetching arbitrary files that don't fit into other package managers. With the generic fetcher, you can easily fetch those files with Hermeto along with your other language-specific dependencies, satisfy the hermetic build condition and have them recorded in the SBOM.</p> <p>Hermeto uses a simple custom lockfile named <code>artifacts.lock.yaml</code> that is expected to be present in the repository, or supplied in JSON input. The lockfile describes the urls, checksums and output filenames for the downloaded files.</p> <p>Currently supported types of artifacts: - Arbitrary files - Maven artifacts</p> <p>See <code>docs/generic.md</code> for more details.</p>"},{"location":"#gomod","title":"gomod","text":"<p>https://go.dev/ref/mod</p> <p>Current version: 1.24 <sup>2</sup> <sup>3</sup></p> <p>The gomod package manager works by parsing the go.mod file present in the source repository to determine which dependencies to download. Hermeto does not parse this file on its own - rather, we rely on the <code>go</code> command to download and list the required dependencies.</p> <p>From go 1.17 onward, the go.mod file includes all the transitively required dependencies of your application - see the section about Pruned module graphs in the 1.17 changelog. In previous go versions, the go.mod file included only direct dependencies. Hermeto does support downloading and listing all transitive dependencies for earlier versions thanks to Go's backwards compatibility<sup>3</sup>. Note that using go &gt;= 1.17 in your project has the added benefit of downloading fewer dependencies (as noted in the changelog), in some cases drastically so.</p> <p>See <code>docs/gomod.md</code> for more details.</p>"},{"location":"#npm","title":"npm","text":"<p>https://docs.npmjs.com/</p> <p>Hermeto supports npm by parsing package-lock.json file present in the source repository and downloading the declared dependencies.</p> <p>To generate lockfile or to make sure the file is up to date, you can use npm install.</p> <p>Make sure lockfile version is higher than v1 (Node.js 15 or higher).</p> <p>See <code>docs/npm.md</code> for more details.</p>"},{"location":"#pip","title":"pip","text":"<p>https://pip.pypa.io/en/stable/</p> <p>Hermeto supports pip by parsing requirements.txt files present in the source repository and downloading the declared dependencies.</p> <p>The files must be lockfiles, i.e. declare all the transitive dependencies and pin them to specific versions. Generating such a lockfile is best done using tools like pip-compile.</p> <p>We support source distribution file format (sdist) as well as binary distribution file format (wheel).</p> <p>See <code>docs/pip.md</code> for more details.</p>"},{"location":"#yarn","title":"yarn","text":"<p>https://yarnpkg.com/</p> <p>Current version: v4</p> <p>Unlike NPM, hermeto merely drives the underlying <code>yarn</code> CLI command operations, that is, hermeto leaves most of the heavy lifting to Yarn itself and it mainly focuses on post-process validation. Note that having a Yarn lockfile (<code>yarn.lock</code>) checked into the repository is paramount for hermeto to process a project successfully. If missing, you can easily generate one by running yarn install prior to pointing hermeto to your project.</p> <p>See <code>docs/yarn.md</code> for more details.</p>"},{"location":"#project-status","title":"Project status","text":"<p>Hermeto was derived (but is not a direct fork) from Cachito.</p> <ol> <li> <p>See for example https://discuss.python.org/t/pip-download-just-the-source-packages-no-building-no-metadata-etc/4651 \u21a9</p> </li> <li> <p>Hermeto expects to use a specific version of the <code>go</code> command when downloading dependencies. This is the   version installed in the hermeto container. We do not guarantee correctness if you run Hermeto   locally (outside the container) with a different Go version. You are free to use a different version to build your   project.\u00a0\u21a9</p> </li> <li> <p>The <code>go</code> command promises to be backwards compatible with previous versions. If your go.mod file specifies   the intended go version, Hermeto should handle it appropriately. If your go version is higher than what Hermeto uses,   there is a good chance it will be compatible regardless, as long as the dependency resolution did not change between   the two versions. For example, dependency resolution did change in go 1.18 but not in   go 1.19. Things are a bit more complicated with Go 1.21, if   you are or have been experiencing issues with hermeto related to Go 1.21+, please refer to   our gomod documentation for more details.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"bundler/","title":"Bundler","text":"<p>https://bundler.io/</p>"},{"location":"bundler/#prerequisites","title":"Prerequisites","text":"<p>To use Hermeto with Bundler locally, ensure you have Ruby and Bundler installed on your system.</p> <pre><code>sudo dnf install rubygem-bundler\n</code></pre> <p>Then ensure you have both, Gemfile and Gemfile.lock in your project directory. We parse the Gemfile.lock to pre-fetch all dependencies specified in that file.</p>"},{"location":"bundler/#basic-usage","title":"Basic usage","text":"<p>Run the following command in your terminal to pre-fetch your project's dependencies. The command will download all dependencies specified in the Gemfile.lock to the specified output directory.</p> <pre><code>cd path-to-your-ruby-project\nhermeto fetch-deps bundler\n</code></pre> <p>In addition, it will prepare the necessary environment variables and configuration files for the build phase. See the following sections for more information.</p>"},{"location":"bundler/#gems","title":"Gems","text":"<p>Each gem has a name, version, and platform. If the platform is \"ruby\", it means that it should work on any platform Ruby runs on. Using the ruby platform means ignoring the current machine's platform and installing only ruby platform gems. As a result, gems with native extensions will be compiled from the source.</p> <p>However, occasionally some gems do not have a version for the ruby platform and are only available as pre-compiled binaries. In this case, you may need to enable the pre-fetching of gems for specific platforms to avoid potential failures with the <code>allow_binary</code> option set to <code>true</code> when running the <code>fetch-deps</code> command.</p> <pre><code>cd path-to-your-ruby-project\nhermeto fetch-deps '{\"type\": \"bundler\", \"allow_binary\": \"true\"}'\n</code></pre> <p>By default, the <code>allow_binary</code> option is disabled.</p>"},{"location":"bundler/#configuration","title":"Configuration","text":"<p>Bundler uses an unorthodox system when dealing with configuration options. The highest precedence is given to the config file, and then to the environment variables. This is a current limitation of Bundler, that we had to work around. We may drop the workaround if this ends up being addressed in future Bundler releases.</p> <p>The order of precedence for Bundler configuration options is as follows:</p> <ol> <li>Local config (<code>&lt;project_root&gt;/.bundle/config or $BUNDLE_APP_CONFIG/config</code>)</li> <li>Environment variables (ENV)</li> <li>Global config (<code>~/.bundle/config</code>)</li> <li>Bundler default config</li> </ol> <p>We set the following configuration options to ensure that the build process works correctly:</p> <ul> <li>BUNDLE_CACHE_PATH: \"${output_dir}/deps/bundler\"</li> <li>BUNDLE_DEPLOYMENT: \"true\"</li> <li>BUNDLE_NO_PRUNE: \"true\"</li> <li>BUNDLE_VERSION: \"system\"</li> <li>BUNDLE_ALLOW_OFFLINE_INSTALL: \"true\"</li> <li>BUNDLE_DISABLE_VERSION_CHECK: \"true\"</li> </ul>"},{"location":"bundler/#bundle_cache_path","title":"BUNDLE_CACHE_PATH","text":"<p>The directory that Bundler will look into when installing gems.</p>"},{"location":"bundler/#bundle_deployment","title":"BUNDLE_DEPLOYMENT","text":"<p>Disallow changes to the Gemfile. When the Gemfile is changed and the lockfile has not been updated, running Bundler commands will be blocked. More importantly though, this makes Bundler comply with network isolated builds. However, this setting has a user-side implication regarding their build recipes, e.g. Dockerfiles<sup>1</sup> and you may want to consider enforcing the installation path for your app explicitly with <code>BUNDLE_PATH</code></p>"},{"location":"bundler/#bundle_no_prune","title":"BUNDLE_NO_PRUNE","text":"<p>Leave outdated gems unpruned.</p>"},{"location":"bundler/#bundle_version","title":"BUNDLE_VERSION","text":"<p>The version of Bundler to use when running under the Bundler environment.</p>"},{"location":"bundler/#bundle_allow_offline_install","title":"BUNDLE_ALLOW_OFFLINE_INSTALL","text":"<p>Allow Bundler to use cached data when installing without network access.</p>"},{"location":"bundler/#bundle_disable_version_check","title":"BUNDLE_DISABLE_VERSION_CHECK","text":"<p>Stop Bundler from checking if a newer Bundler version is available on rubygems.org.</p> <p>Note: A prefetch could fail when Bundler versions differ between the build system and lockfile and when the former is outdated. Therefore we do not recommend using mismatching or outdated versions of Bundler in build systems as this might result in unexpected failures.</p> <p>To create the configuration file, run the following command.</p> <pre><code>hermeto inject-files --for-output-dir /tmp/hermeto-output hermeto-output\n</code></pre> <p>You should see a log message that the file was created successfully. Lastly, you need to set the <code>BUNDLE_APP_CONFIG</code> environment variable to point to the copied configuration file.</p> <pre><code>hermeto generate-env --output ./hermeto.env --for-output-dir /tmp/hermeto-output ./hermeto-output\n</code></pre> <pre><code># cat hermeto.env\nexport BUNDLE_APP_CONFIG=/tmp/hermeto-output/bundler/config_override\n</code></pre> <p>The generated environment file should be sourced before running any Bundler command.</p>"},{"location":"bundler/#limitations","title":"Limitations","text":"<p>Since the local configuration takes higher precedence than the environment variables (except <code>BUNDLE_APP_CONFIG</code>), we copy the configuration file and overwrite the environment variables above. Then, we change the <code>BUNDLE_APP_CONFIG</code> environment variable to point to the new configuration file.</p> <p>It should not affect the build process unless you have multiple packages in your repository with different configuration settings. In that case, you may have to adjust the build phase accordingly.</p>"},{"location":"bundler/#hermetic-build","title":"Hermetic build","text":"<p>After using the <code>fetch-deps</code>, <code>inject-files</code>, and <code>generate-env</code> commands to set up the directory, building the Dockerfile will produce a container with the application fully compiled without any network access. The build will be hermetic and reproducible.</p> <pre><code>FROM docker.io/library/ruby:latest\n\nWORKDIR /app\n\nCOPY Gemfile .\nCOPY Gemfile.lock .\n\n...\n\nRUN . /tmp/hermeto.env &amp;&amp; bundle install\n\n...\n</code></pre> <p>Assuming <code>hermeto-output</code> and <code>hermeto.env</code> are in the same directory as the Dockerfile, build the image with the following command:</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag my-ruby-app\n</code></pre>"},{"location":"bundler/#unsupported-features","title":"Unsupported features","text":"<ul> <li>checksum validation (blocked by pending official support)</li> <li>downloading the Bundler version specified in the Gemfile.lock</li> <li>reporting development dependencies</li> <li>plugins</li> </ul> <ol> <li> <p><code>BUNDLE_DEPLOYMENT</code> enforces deployment mode which is essentially vendoring your application and its dependencies. In other words, deployment will install your application to a local <code>vendor/bundle</code> directory instead of using the standard system-wide location. This is currently the only way of forcing bundler to respect and use the offline package cache during hermetic builds. Note that the deployment mode doesn't play nicely with other installation flags and so trying to use <code>--local</code> with your <code>bundle install</code> command in your Dockerfile won't take effect, consider <code>BUNDLE_PATH</code> instead.\u00a0\u21a9</p> </li> </ol>"},{"location":"cargo/","title":"Cargo","text":"<p>https://doc.rust-lang.org/cargo/</p>"},{"location":"cargo/#prerequisites","title":"Prerequisites","text":"<p>To use Hermeto with Cargo locally, ensure you have Cargo binary installed on your system. Then, ensure that the Cargo.toml and Cargo.lock are in your project directory.</p>"},{"location":"cargo/#usage","title":"Usage","text":"<p>Run the following commands in your terminal to prefetch your project's dependencies specified in the Cargo.lock. It must be synchronized with the Cargo.toml file. Otherwise, the command will fail.</p> <pre><code>cd path-to-your-rust-project\nhermeto fetch-deps cargo\n</code></pre> <p>The default output directory is <code>hermeto-output</code>. You can change it by passing the <code>--output-dir</code> option for the <code>fetch-deps</code> command. See the help message for more information.</p> <p>After prefetching the dependencies, you can use the <code>hermeto inject-files</code> command to update the <code>.cargo/config.toml</code> file in your project directory. If it does not exist, it will be created. The file will contain instructions for Cargo to use the prefetched dependencies when compiling a project.</p> <p>Use the <code>--for-output-dir</code> option to specify the location where you want to mount the <code>hermeto-output</code> in your container build environment. See the next section.</p> <p>Do not forget to copy <code>.cargo/config.toml</code> when building your container image.</p> <pre><code>hermeto inject-files --for-output-dir /tmp/hermeto-output hermeto-output\n</code></pre> <p>There are no environment variables that need to be set for the build phase.</p>"},{"location":"cargo/#hermetic-build","title":"Hermetic build","text":"<p>After using the <code>fetch-deps</code>, and <code>inject-files</code> commands to set up the directory, you can build your project hermetically. Here is an example of a Dockerfile with basic instructions to build a Rust project:</p> <pre><code>FROM docker.io/library/rust:latest\n\nWORKDIR /app\n\nCOPY Cargo.toml Cargo.lock .cargo .\n\nRUN cargo build --release\n</code></pre> <p>Do not forget to mount the <code>hermeto-output</code> directory to the container build environment.</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --network none \\\n  --tag my-rust-app\n</code></pre>"},{"location":"generic/","title":"Generic fetcher","text":"<ul> <li>Specifying artifacts to fetch</li> <li>Using fetched dependencies</li> </ul>"},{"location":"generic/#support-scope","title":"Support scope","text":"<p>Generic fetcher is made specifically for use cases where hermeto will not implement a full package manager support, or for ecosystems where no such package manager exists. It is highly discouraged for this feature to be used for anything already supported by hermeto in other ways (such as e.g. pip packages), because the produced SBOM component will not be accurate. </p>"},{"location":"generic/#specifying-artifacts-to-fetch","title":"Specifying artifacts to fetch","text":"<p>The generic fetcher requires a lockfile <code>artifacts.lock.yaml</code> that specifies which files to download. This file is expected to be in the source repository. Alternatively, it can be supplied as an absolute path via the <code>lockfile</code> key in the JSON input to hermeto.</p> <p>Below are sections for each type of supported artifact. Several artifacts of different types can be specified in a single lockfile.</p> <p>The lockfile must always contain a <code>metadata</code> header and a list of <code>artifacts</code>. Currently, the only supported version is 1.0:</p> <pre><code>---\nmetadata:\n  version: \"1.0\"\nartifacts: []\n</code></pre> <p>Hermeto can be then ran as follows:</p> <pre><code>\nhermeto fetch-deps \\\n--source ./my-repo \\\n--output ./hermeto-output \\\n'&lt;JSON input&gt;'\n</code></pre> <p>JSON input:</p> <pre><code>{\n  \"type\": \"generic\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n  // option to specify lockfile path, must be an absolute path if specified\n  // defaults to \"artifacts.lock.yaml\", relative to path\n  \"lockfile\": \"artifacts.lock.yaml\",\n}\n</code></pre>"},{"location":"generic/#arbitrary-files","title":"Arbitrary files","text":"<p>This artifact type is intended for whatever files are needed at build time that do not fit neatly into other package managers.</p> <pre><code>---\nmetadata:\n  version: \"1.0\"\nartifacts:\n  - download_url: \"https://example.com/file.zip\"\n    checksum: \"algorithm:hash\"\n    filename: \"optional-custom-name.zip\"  # optional\n</code></pre> <p>Each artifact requires: - <code>download_url</code>: The URL to download the file from - <code>checksum</code>: In format \"algorithm:hash\" (e.g., \"sha256:123...\") - <code>filename</code>: Optional custom filename for the downloaded file. If not present, it will be derived from the url</p>"},{"location":"generic/#sbom-component","title":"SBOM component","text":"<p>Since there can't be any assumptions about these files beyond checking their identity against a checksum, these files will be reported with <code>pkg:generic</code> purl in the output SBOM. </p>"},{"location":"generic/#maven-artifacts","title":"Maven artifacts","text":"<p>This type is for downloading maven repository artifacts. These are specified using GAV coordinates that are enumerated in the artifact's attributes in the lockfile. The download URL will be assembled using this information.</p> <pre><code>---\nmetadata:\n    version: \"1.0\"\nartifacts:\n    - type: \"maven\"\n      filename: \"ant.jar\"\n      attributes:\n          repository_url: \"https://repo1.maven.org/maven2\"\n          group_id: \"org.apache.ant\"\n          artifact_id: \"ant\"\n          version: \"1.10.14\"\n          type: \"jar\"\n      checksum: \"sha256:4cbbd9243de4c1042d61d9a15db4c43c90ff93b16d78b39481da1c956c8e9671\"\n</code></pre> <p>Each artifact requires: - <code>type</code>: type of the artifact (always <code>maven</code>) - <code>filename</code>: Optional custom filename for the downloaded file. If not present, it will be derived from the url - <code>attributes</code>: Maven-specific attributes   - <code>repository_url</code>: URL of the Maven repository (required)   - <code>group_id</code>: Maven group ID  (required)   - <code>artifact_id</code>: Maven artifact ID  (required)   - <code>version</code>: Version of the artifact (required)   - <code>type</code>: Type of the artifact (\"jar\" by default)   - <code>classfier</code>: Maven classifier (optional)</p> <ul> <li><code>checksum</code>: In format \"algorithm:hash\" (e.g., \"sha256:123...\")</li> </ul>"},{"location":"generic/#sbom-component_1","title":"SBOM component","text":"<p>These files will be reported with <code>pkg:maven</code> purl in the output SBOM, because the URL is fully assembled from the provided attributes and therefore the file can be assumed to be a maven artifact.</p>"},{"location":"generic/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>Hermeto downloads the files into the <code>deps/generic/</code> subpath of the output directory. Files are named according to the <code>filename</code> field if specified, otherwise derived from the URL. During your build, you would typically mount hermeto's output directory into your container image and reference the individual files. For a detailed example, see usage.md.</p>"},{"location":"gomod/","title":"gomod","text":"<p>https://go.dev/ref/mod</p> <ul> <li>Specifying modules to process</li> <li>Using fetched dependencies</li> <li>gomod flags</li> <li>Vendoring</li> <li>Understanding reported dependencies</li> <li>Go 1.21+</li> </ul>"},{"location":"gomod/#specifying-modules-to-process","title":"Specifying modules to process","text":"<pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;modules JSON&gt;'\n</code></pre> <p>Module<sup>1</sup> JSON:</p> <pre><code>{\n  // \"gomod\" tells Hermeto to process a go module\n  \"type\": \"gomod\",\n  // path to the module (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\"\n}\n</code></pre> <p>The main argument accepts alternative forms of input, see usage: pre-fetch-dependencies.</p>"},{"location":"gomod/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See also usage.md for a complete example of Hermeto usage.</p> <p>Hermeto downloads the required modules into the deps/gomod/ subpath of the output directory (<code>hermeto-output/deps/gomod</code>). Further down the file tree, at <code>hermeto-output/deps/gomod/pkg/mod</code>, is a directory formatted as the Go module cache.</p> <pre><code>hermeto-output/deps/gomod/pkg/mod\n\u2514\u2500\u2500 cache\n    \u2514\u2500\u2500 download\n        \u251c\u2500\u2500 github.com\n        \u2502   \u2514\u2500\u2500 ...\n        \u2514\u2500\u2500 golang.org\n            \u2514\u2500\u2500 ...\n</code></pre> <p>To use this module cache during your build, set the GOMODCACHE environment variable. Hermeto generates GOMODCACHE along with other expected environment variables for you. See usage: generate environment variables for more details.</p> <p>For more information on Go's environment variables:</p> <pre><code>go help environment\n</code></pre> <p>Note that the deps/gomod/ layout described above does not apply when using vendoring. With vendoring enabled, deps/gomod/ will be an empty directory. Instead, dependencies will be inside the vendor subdirectory of your module.</p> <pre><code>my-repo\n\u2514\u2500\u2500 vendor\n    \u251c\u2500\u2500 github.com\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 golang.org\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 modules.txt\n</code></pre> <p>Go will use the vendored dependencies automatically, but it's not a bad idea to set the environment variables generated by Hermeto anyway.</p>"},{"location":"gomod/#gomod-flags","title":"gomod flags","text":"<p>The <code>hermeto fetch-deps</code> command accepts the following gomod-related flags:</p>"},{"location":"gomod/#-cgo-disable","title":"--cgo-disable","text":"<p>Makes Hermeto internally disable cgo while processing your Go modules. Typically, you would want to use this flag if your modules do use C code and Hermeto is failing to process them. Hermeto will not attempt to disable cgo in your build (nor should you disable it yourself if you rely on C).</p> <p>Disabling cgo should not prevent Hermeto from fetching your Go dependencies as usual. Note that Hermeto will not make any attempts to fetch missing C libraries. If required, you would need to get them through other means.</p>"},{"location":"gomod/#deprecated-flags","title":"Deprecated flags","text":"<ul> <li><code>--gomod-vendor</code> (deprecated in v0.11.0)</li> <li><code>--gomod-vendor-check</code> (deprecated in v0.11.0)</li> <li><code>--force-gomod-tidy</code> (deprecated in v0.18.0)</li> </ul> <p>All of them are deprecated and will have no effect when set. They are only kept for backwards compatibility reasons and will be removed in future releases.</p>"},{"location":"gomod/#vendoring","title":"Vendoring","text":"<p>Go supports vendoring to store the source code of all dependencies in the vendor/ directory alongside your module. Before go 1.17, <code>go mod vendor</code> used to download fewer dependencies than <code>go mod download</code>. Starting with 1.17, that is no longer true.</p> <p>We generally discourage vendoring, but Hermeto does support processing repositories that contain vendored content. In this case, instead of a regular prefetching of dependencies, Hermeto will only validate if the contents of the vendor directory are consistent with what <code>go mod vendor</code> would produce.</p>"},{"location":"gomod/#understanding-reported-dependencies","title":"Understanding reported dependencies","text":"<p>Hermeto reports two (arguably three) different types of dependencies in the generated SBOM for your Go modules:</p> <ul> <li>gomod dependencies (Go modules)</li> <li>go-package dependencies (Go packages)</li> <li>from the downloaded modules</li> <li>from the standard library</li> </ul>"},{"location":"gomod/#gomod-vs-go-package","title":"gomod vs go-package","text":"<p>Best explained by the Go modules documentation:</p> <p>A module is a collection of packages that are released, versioned, and distributed together.</p> <p>Your Go code imports individual packages, which come from modules. You might import a single package from a module that provides many, but Go (and Hermeto) has to download the whole module anyway. Effectively, modules are the smallest \"unit of distribution.\" Go does have the ability to list the individual packages that your project imports. Hermeto makes use of this ability to report both the downloaded modules and the required packages.</p> <p>The list of go-package dependencies reported by Hermeto is the full set of packages (transitively) required by your project. \u26a0 If any of your module dependencies is missing a checksum in go.sum, the list may be incomplete.</p> <p>The list of gomod dependencies is the set of modules that Hermeto downloaded to satisfy the go-package dependencies.</p> <p>Note that versioning applies to modules, not packages. When reporting the versions of Go packages, Hermeto uses the version of the module that provides the package.</p>"},{"location":"gomod/#how-to-match-a-package-to-a-module","title":"How to match a package to a module?","text":"<p>Borrowing from the modules documentation again:</p> <p>For example, the module \"golang.org/x/net\" contains a package in the directory \"html\". That package\u2019s path is   \"golang.org/x/net/html\"</p> <p>The name of a package starts with the name of the module that provides it.</p>"},{"location":"gomod/#in-the-source-tree-what-are-modules-what-are-packages","title":"In the source tree, what are modules? What are packages?","text":"<p>To simplify a little:</p> <ul> <li>Does the directory have a <code>go.mod</code> file? It's a module (provides packages).</li> <li>Does the directory have any <code>*.go</code> files? It's a package (is importable).</li> <li>Does it have both? It's both a module and a package.</li> </ul>"},{"location":"gomod/#stdlib-dependencies","title":"stdlib dependencies","text":"<p>Go is able to list even the standard library packages that your project imports. Hermeto exposes these as go-package dependencies, with caveats. Hermeto uses some version of Go to list the dependencies. This may or may not be the same version that you will use to build your project. We do not presume that the versions would be the same, hence why:</p> <ul> <li>the reported stdlib packages may be slightly inaccurate (e.g. new packages in new Go versions)</li> <li>the versions of stdlib packages are not reported</li> </ul>"},{"location":"gomod/#what-identifies-stdlib-dependencies-in-the-go-package-list","title":"What identifies stdlib dependencies in the go-package list?","text":"<ul> <li>does not have a version</li> <li>the name does not start with a hostname</li> <li><code>io/fs</code> - standard library</li> <li><code>golang.org/x/net</code> - external</li> </ul>"},{"location":"gomod/#missing-checksums","title":"Missing checksums","text":"<p>Go stores the checksums of all your dependency modules in the go.sum file. Go typically manages this file entirely on its own, but if any of your dependencies do end up missing, it can cause issues for Hermeto and for Go itself.</p> <p>For Hermeto, a missing checksum means that the offending module gets downloaded without checksum verification (or with partial checksum verification - Hermeto does consult the Go checksum database). Due to <code>go list</code> behavior, it also means that the go-package dependency listing may be incomplete<sup>2</sup>.</p> <p>For Go, a missing checksum will cause the <code>go build</code> or <code>go run</code> commands to fail.</p> <p>Please make sure to keep your go.sum file up to date, perhaps by incorporating the <code>go mod tidy</code> command in your dev workflow.</p>"},{"location":"gomod/#go-121-since-v050","title":"Go 1.21+ (since v0.5.0)","text":"<p>Starting with Go 1.21, Go changed the meaning of the <code>go 1.X</code> directive in   that it now specifies the minimum required version of Go   rather than a suggested version as it originally did. The format of the version string in the   <code>go</code> directive now also includes the micro release and if you don't include the micro release in   your <code>go.mod</code> file yourself (i.e. you only specify the language release) Go will try to correct   it automatically inside the file. Last but not least, Go 1.21 also introduced a new keyword   <code>toolchain</code> to the <code>go.mod</code> file. What this all   means in practice for end users is that you may not be able to process your <code>go.mod</code> file with an   older version of Go (and hence older hermeto) as you could in the past for various reasons.   Many projects bump their required Go toolchain's micro release as soon as it becomes available   upstream (i.e. not waiting for distributions to bundle them properly). This caused problems in   version v0.5.0 because the container image's version simply may not have been high enough to   process a given project's <code>go.mod</code> file. Therefore, version v0.7.0 introduced a mechanism to   always rely on the origin 0th release of a toolchain (e.g. 1.21.0) and use the <code>GOTOOLCHAIN=auto</code>   setting to instruct Go to fetch any toolchain as specified by the <code>go.mod</code> file automatically,   hence allowing us to keep up with frequent micro version bumps. Note that such a language   version would still need to be officially marked as supported by hermeto, i.e. we'd not allow Go   to fetch e.g. a 1.22 toolchain if the maximum supported Go version by hermeto were 1.21!</p> <ol> <li> <p>You may have noticed a slight naming issue. You use the main argument, also called PKG, to specify a module to   process. Even worse, Go has packages as well (see gomod vs go-package). What gives?   As far as we know, most languages/package managers use the opposite naming. For example, in Python,   modules are <code>*.py</code> files, packages are collections of modules. In npm, modules are directories/files   you can <code>require()</code>, packages are the top-level directories with <code>package.json</code>. In Hermeto, we stick to the more   common naming.\u00a0\u21a9</p> </li> <li> <p>When a module does not have a checksum in go.sum, the <code>go list</code> command returns only basic   information and an error for the packages from said module. Go doesn't return any information about the dependencies   of the affected packages. This can cause Hermeto to miss the transitive package dependencies of packages from   checksum-less modules.\u00a0\u21a9</p> </li> </ol>"},{"location":"npm/","title":"npm","text":"<p>https://docs.npmjs.com/</p> <ul> <li>Specifying packages to process</li> <li>Project files</li> <li>Dependencies</li> <li>Project example</li> <li>Using fetched dependencies</li> <li>Changes made by the inject-files command</li> <li>Updated project example</li> </ul>"},{"location":"npm/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>A package is a file or directory that is described by a package.json file.</p> <ul> <li>The project files for npm are package.json and one of package-lock.json or npm-shrinkwrap.json. See Project files and npm documentation:</li> <li>See package.json</li> <li>See package-lock.json</li> </ul> <p>Notice that the package-lock.json version must be higher than v1 (Node.js 15 or higher)! Package-lock.json v1 is not supported in Hermeto.</p> <p>Hermeto fetch-deps shell command:</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>JSON input:</p> <pre><code>{\n  // \"npm\" tells Hermeto to process npm packages\n  \"type\": \"npm\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n}\n</code></pre>"},{"location":"npm/#project-files","title":"Project files","text":"<p>Hermeto downloads dependencies explicitly declared in project files - package.json and package-lock.json. The npm CLI manages the package-lock.json file automatically. To make sure the file is up to date, you can use npm install.</p> <p>Possible dependency types in the above-mentioned files are described in the following section.</p>"},{"location":"npm/#dependencies","title":"Dependencies","text":"<p>The \"npm package\" formats that Hermeto can process are the following:</p> <pre><code>1. A folder containing a program described by a package.json file.\n2. A gzipped tarball containing (1.).\n3. A URL that resolves to (2.).\n4. A &lt;name&gt;@&lt;version&gt; that is published on the registry with (3.).\n5. A &lt;name&gt;@&lt;tag&gt; that points to (4.).\n6. A &lt;name&gt; that has a latest tag satisfying (5.).\n7. A git url that, when cloned, results in (1.).\n</code></pre> <p>Examples of (package.json) dependency formats: (For the full list of dependency formats with explanation, See npm documentation).</p> Dependencies from npm registries <pre><code>{\n  \"dependencies\": {\n    \"foo\": \"1.0.0 - 2.9999.9999\",\n    \"bar\": \"&gt;=1.0.2 &lt;2.1.2\",\n    \"baz\": \"&gt;1.0.2 &lt;=2.3.4\",\n    \"boo\": \"2.0.1\",\n    ...\n  }\n}\n</code></pre> URLs as dependencies <pre><code>{\n  \"dependencies\": {\n    \"cli_bar\": git+ssh://git@github.com:npm/cli.git#v1.0.27,\n    \"cli_foo\": git://github.com/npm/cli.git#v1.0.1\n  }\n}\n</code></pre> GitHub URLs <pre><code>{\n  \"dependencies\": {\n    \"express\": \"expressjs/express\",\n    \"mocha\": \"mochajs/mocha#4727d357ea\",\n    \"module\": \"user/repo#feature/branch\"\n  }\n}\n</code></pre> Local paths <pre><code>{\n  \"name\": \"baz\",\n  \"dependencies\": {\n    \"bar\": \"file:../foo/bar\"\n  }\n}\n</code></pre>"},{"location":"npm/#project-example","title":"Project example:","text":"package.json <pre><code>{\n  \"name\": \"npm-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"react-dom\": \"^18.0.1\",\n        \"@types/react-dom\": \"^18.0.1\",\n        \"bitbucket-cachi2-npm-without-deps-second\": \"git+https://bitbucket.org/cachi-testing/cachi2-without-deps-second.git\",\n        \"cachito-npm-without-deps\": \"https://github.com/cachito-testing/cachito-npm-without-deps/raw/tarball/cachito-npm-without-deps-1.0.0.tgz\",\n        \"fecha\": \"file:fecha-4.2.3.tgz\"\n  },\n  \"workspaces\": [\n    \"foo\"\n  ]\n}\n</code></pre> package-lock.json <pre><code>{\n  \"name\": \"cachi2-npm-demo\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"cachi2-npm-demo\",\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"workspaces\": [\n        \"foo\"\n      ],\n      \"dependencies\": {\n        \"@types/react-dom\": \"^18.0.1\",\n        \"bitbucket-cachi2-npm-without-deps-second\": \"git+https://bitbucket.org/cachi-testing/cachi2-without-deps-second.git\",\n        \"cachito-npm-without-deps\": \"https://github.com/cachito-testing/cachito-npm-without-deps/raw/tarball/cachito-npm-without-deps-1.0.0.tgz\",\n        \"fecha\": \"file:fecha-4.2.3.tgz\",\n        \"react-dom\": \"^18.0.1\"\n      }\n    },\n    \"foo\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"is-positive\": \"github:kevva/is-positive\"\n      },\n      \"devDependencies\": {}\n    },\n    \"node_modules/@types/prop-types\": {\n      \"version\": \"15.7.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.5.tgz\",\n      \"integrity\": \"sha512-JCB8C6SnDoQf0cNycqd/35A7MjcnK+ZTqE7judS6o7utxUCg6imJg3QK2qzHKszlTjcj2cn+NwMB2i96ubpj7w==\"\n    },\n    \"node_modules/@types/react\": {\n      \"version\": \"18.2.18\",\n      \"resolved\": \"https://registry.npmjs.org/@types/react/-/react-18.2.18.tgz\",\n      \"integrity\": \"sha512-da4NTSeBv/P34xoZPhtcLkmZuJ+oYaCxHmyHzwaDQo9RQPBeXV+06gEk2FpqEcsX9XrnNLvRpVh6bdavDSjtiQ==\",\n      \"dependencies\": {\n        \"@types/prop-types\": \"*\",\n        \"@types/scheduler\": \"*\",\n        \"csstype\": \"^3.0.2\"\n      }\n    },\n    \"node_modules/@types/react-dom\": {\n      \"version\": \"18.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/@types/react-dom/-/react-dom-18.2.7.tgz\",\n      \"integrity\": \"sha512-GRaAEriuT4zp9N4p1i8BDBYmEyfo+xQ3yHjJU4eiK5NDa1RmUZG+unZABUTK4/Ox/M+GaHwb6Ow8rUITrtjszA==\",\n      \"dependencies\": {\n        \"@types/react\": \"*\"\n      }\n    },\n    \"node_modules/@types/scheduler\": {\n      \"version\": \"0.16.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/scheduler/-/scheduler-0.16.3.tgz\",\n      \"integrity\": \"sha512-5cJ8CB4yAx7BH1oMvdU0Jh9lrEXyPkar6F9G/ERswkCuvP4KQZfZkSjcMbAICCpQTN4OuZn8tz0HiKv9TGZgrQ==\"\n    },\n    \"node_modules/bitbucket-cachi2-npm-without-deps-second\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"git+ssh://git@bitbucket.org/cachi-testing/cachi2-without-deps-second.git#09992d418fc44a2895b7a9ff27c4e32d6f74a982\"\n    },\n    \"node_modules/cachito-npm-without-deps\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://github.com/cachito-testing/cachito-npm-without-deps/raw/tarball/cachito-npm-without-deps-1.0.0.tgz\",\n      \"integrity\": \"sha512-Q+cfkK1fnrNJqxiig/iVSZTe83OWLdxhuGa96k1IJJ5nkTxrhNyh6MUZ6YHKH8xitDgpIQSojuntctt2pB7+3g==\"\n    },\n    \"node_modules/csstype\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/csstype/-/csstype-3.1.2.tgz\",\n      \"integrity\": \"sha512-I7K1Uu0MBPzaFKg4nI5Q7Vs2t+3gWWW648spaF+Rg7pI9ds18Ugn+lvg4SHczUdKlHI5LWBXyqfS8+DufyBsgQ==\"\n    },\n    \"node_modules/fecha\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"file:fecha-4.2.3.tgz\",\n      \"integrity\": \"sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/foo\": {\n      \"resolved\": \"foo\",\n      \"link\": true\n    },\n    \"node_modules/is-positive\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"git+ssh://git@github.com/kevva/is-positive.git#97edff6f525f192a3f83cea1944765f769ae2678\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\"\n    },\n    \"node_modules/loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dependencies\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      },\n      \"bin\": {\n        \"loose-envify\": \"cli.js\"\n      }\n    },\n    \"node_modules/react\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/react/-/react-18.2.0.tgz\",\n      \"integrity\": \"sha512-/3IjMdb2L9QbBdWiW5e3P2/npwMBaU9mHCSCUzNln0ZCYbcfTsGbTJrU/kGemdH2IWmB2ioZ+zkxtmq6g09fGQ==\",\n      \"peer\": true,\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/react-dom\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/react-dom/-/react-dom-18.2.0.tgz\",\n      \"integrity\": \"sha512-6IMTriUmvsjHUjNtEDudZfuDQUoWXVxKHhlEGSk81n4YFS+r/Kl99wXiwlVXtPBtJenozv2P+hxDsw9eA7Xo6g==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\",\n        \"scheduler\": \"^0.23.0\"\n      },\n      \"peerDependencies\": {\n        \"react\": \"^18.2.0\"\n      }\n    },\n    \"node_modules/scheduler\": {\n      \"version\": \"0.23.0\",\n      \"resolved\": \"https://registry.npmjs.org/scheduler/-/scheduler-0.23.0.tgz\",\n      \"integrity\": \"sha512-CtuThmgHNg7zIZWAXi3AsyIzA3n4xx7aNyjwC2VJldO2LMVDhFK+63xGqq6CsJH4rTAt6/M+N4GhZiDYPx9eUw==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      }\n    }\n  }\n}\n</code></pre> foo/package.json (workspace) <pre><code>{\n  \"name\": \"foo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n      \"is-positive\": \"github:kevva/is-positive\"\n  }\n}\n</code></pre>"},{"location":"npm/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See also usage.md for a complete example of Hermeto usage.</p> <p>Hermeto downloads the npm dependencies as tar archives into the <code>deps/npm/</code> subpath of the output directory.</p> <ol> <li>Dependencies fetched from npm registries are placed directly to this directory (array-flatten in the following example).</li> <li>Dependencies downloaded from other HTTPS URL are placed to subdirectory <code>external-&lt;tarball_name&gt;</code> (bar-project in the following example).</li> <li>Dependencies retrieved from Git repository are placed to <code>host, namespace, repo</code> subdirectories (foo-project in the following example).</li> </ol> <pre><code>hermeto-output/deps/npm\n\u251c\u2500\u2500 array-flatten-1.1.1.tgz\n\u251c\u2500\u2500 bitbucket.org\n\u2502        \u2514\u2500\u2500 foo-testing\n\u2502             \u2514\u2500\u2500 foo-project\n\u2502                       \u2514\u2500\u2500 foo-project-external-gitcommit-9e164b97043a2d91bbeb992f6cc68a3d1015086a.tgz\n\u251c\u2500\u2500 body-parser-1.20.1.tgz\n\u251c\u2500\u2500 bytes-3.1.2.tgz\n\u2502   ...\n\u251c\u2500\u2500 external-bar-project\n\u2502        \u2514\u2500\u2500 bar-project-external-sha512-43e71f90ad5YOLO.tgz\n\u2502   ...\n</code></pre> <p>In order for the <code>npm install</code> command to use the fetched dependencies instead of reaching for the npm registry, Hermeto needs to update project files. These updates happen automatically when we call the Hermeto's inject-files command.</p>"},{"location":"npm/#changes-made-by-the-inject-files-command","title":"Changes made by the inject-files command","text":"<p>The root <code>package.json</code> file is updated together with package.json files for each workspace with changes: * For git repositories and HTTPS URLs in dependencies update their value to an empty string</p> <p>Hermeto command updates the following in the <code>package-lock.json</code> file: * Replace URLs found in resolved items with local paths to fetched dependencies. * Similarly to the above package.json changes, for git repositories and HTTPS URLs in package dependencies update their value to an empty string. * There is a corner case bug which happens in older npm versions (spotted in 8.12.1 version and lower) where npm mistakenly adds integrity checksum to git sources. To avoid errors while recreating git repository content as a tar archive and changing the integrity checksum,   Hermeto deletes integrity items, which should not be there in the first place.</p>"},{"location":"npm/#updated-project-example","title":"Updated project example","text":"package.json <pre><code>{\n  \"name\": \"cachi2-npm-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"react-dom\": \"^18.0.1\",\n    \"@types/react-dom\": \"^18.0.1\",\n    \"bitbucket-cachi2-npm-without-deps-second\": \"\",\n    \"cachito-npm-without-deps\": \"\",\n    \"fecha\": \"file:fecha-4.2.3.tgz\"\n  },\n  \"workspaces\": [\n    \"foo\"\n  ]\n}\n</code></pre> package-lock.json <pre><code>{\n  \"name\": \"cachi2-npm-demo\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"cachi2-npm-demo\",\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"workspaces\": [\n        \"foo\"\n      ],\n      \"dependencies\": {\n        \"@types/react-dom\": \"^18.0.1\",\n        \"bitbucket-cachi2-npm-without-deps-second\": \"\",\n        \"cachito-npm-without-deps\": \"\",\n        \"fecha\": \"file:fecha-4.2.3.tgz\",\n        \"react-dom\": \"^18.0.1\"\n      }\n    },\n    \"foo\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"is-positive\": \"\"\n      },\n      \"devDependencies\": {}\n    },\n    \"node_modules/@types/prop-types\": {\n      \"version\": \"15.7.5\",\n      \"resolved\": \"file:///tmp/deps/npm/types-prop-types-15.7.5.tgz\",\n      \"integrity\": \"sha512-JCB8C6SnDoQf0cNycqd/35A7MjcnK+ZTqE7judS6o7utxUCg6imJg3QK2qzHKszlTjcj2cn+NwMB2i96ubpj7w==\"\n    },\n    \"node_modules/@types/react\": {\n      \"version\": \"18.2.18\",\n      \"resolved\": \"file:///tmp/deps/npm/types-react-18.2.18.tgz\",\n      \"integrity\": \"sha512-da4NTSeBv/P34xoZPhtcLkmZuJ+oYaCxHmyHzwaDQo9RQPBeXV+06gEk2FpqEcsX9XrnNLvRpVh6bdavDSjtiQ==\",\n      \"dependencies\": {\n        \"@types/prop-types\": \"*\",\n        \"@types/scheduler\": \"*\",\n        \"csstype\": \"^3.0.2\"\n      }\n    },\n    \"node_modules/@types/react-dom\": {\n      \"version\": \"18.2.7\",\n      \"resolved\": \"file:///tmp/deps/npm/types-react-dom-18.2.7.tgz\",\n      \"integrity\": \"sha512-GRaAEriuT4zp9N4p1i8BDBYmEyfo+xQ3yHjJU4eiK5NDa1RmUZG+unZABUTK4/Ox/M+GaHwb6Ow8rUITrtjszA==\",\n      \"dependencies\": {\n        \"@types/react\": \"*\"\n      }\n    },\n    \"node_modules/@types/scheduler\": {\n      \"version\": \"0.16.3\",\n      \"resolved\": \"file:///tmp/deps/npm/types-scheduler-0.16.3.tgz\",\n      \"integrity\": \"sha512-5cJ8CB4yAx7BH1oMvdU0Jh9lrEXyPkar6F9G/ERswkCuvP4KQZfZkSjcMbAICCpQTN4OuZn8tz0HiKv9TGZgrQ==\"\n    },\n    \"node_modules/bitbucket-cachi2-npm-without-deps-second\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"file:///tmp/deps/npm/bitbucket.org/cachi-testing/cachi2-without-deps-second/cachi2-without-deps-second-external-gitcommit-09992d418fc44a2895b7a9ff27c4e32d6f74a982.tgz\"\n    },\n    \"node_modules/cachito-npm-without-deps\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"file:///tmp/deps/npm/external-cachito-npm-without-deps/cachito-npm-without-deps-external-sha512-43e71f90ad5f9eb349ab18a283f8954994def373962ddc61b866bdea4d48249e67913c6b84dca1e8c519e981ca1fcc62b438292104a88ee9ed72db76a41efede.tgz\",\n      \"integrity\": \"sha512-Q+cfkK1fnrNJqxiig/iVSZTe83OWLdxhuGa96k1IJJ5nkTxrhNyh6MUZ6YHKH8xitDgpIQSojuntctt2pB7+3g==\"\n    },\n    \"node_modules/csstype\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"file:///tmp/deps/npm/csstype-3.1.2.tgz\",\n      \"integrity\": \"sha512-I7K1Uu0MBPzaFKg4nI5Q7Vs2t+3gWWW648spaF+Rg7pI9ds18Ugn+lvg4SHczUdKlHI5LWBXyqfS8+DufyBsgQ==\"\n    },\n    \"node_modules/fecha\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"file:fecha-4.2.3.tgz\",\n      \"integrity\": \"sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/foo\": {\n      \"resolved\": \"foo\",\n      \"link\": true\n    },\n    \"node_modules/is-positive\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"file:///tmp/deps/npm/github.com/kevva/is-positive/is-positive-external-gitcommit-97edff6f525f192a3f83cea1944765f769ae2678.tgz\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"file:///tmp/deps/npm/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\"\n    },\n    \"node_modules/loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"file:///tmp/deps/npm/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dependencies\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      },\n      \"bin\": {\n        \"loose-envify\": \"cli.js\"\n      }\n    },\n    \"node_modules/react\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"file:///tmp/deps/npm/react-18.2.0.tgz\",\n      \"integrity\": \"sha512-/3IjMdb2L9QbBdWiW5e3P2/npwMBaU9mHCSCUzNln0ZCYbcfTsGbTJrU/kGemdH2IWmB2ioZ+zkxtmq6g09fGQ==\",\n      \"peer\": true,\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/react-dom\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"file:///tmp/deps/npm/react-dom-18.2.0.tgz\",\n      \"integrity\": \"sha512-6IMTriUmvsjHUjNtEDudZfuDQUoWXVxKHhlEGSk81n4YFS+r/Kl99wXiwlVXtPBtJenozv2P+hxDsw9eA7Xo6g==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\",\n        \"scheduler\": \"^0.23.0\"\n      },\n      \"peerDependencies\": {\n        \"react\": \"^18.2.0\"\n      }\n    },\n    \"node_modules/scheduler\": {\n      \"version\": \"0.23.0\",\n      \"resolved\": \"file:///tmp/deps/npm/scheduler-0.23.0.tgz\",\n      \"integrity\": \"sha512-CtuThmgHNg7zIZWAXi3AsyIzA3n4xx7aNyjwC2VJldO2LMVDhFK+63xGqq6CsJH4rTAt6/M+N4GhZiDYPx9eUw==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      }\n    }\n  }\n}\n</code></pre> foo/package.json (workspace) <pre><code>{\n  \"name\": \"foo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n      \"is-positive\": \"\"\n  }\n}\n</code></pre>"},{"location":"pip/","title":"pip","text":"<p>https://pip.pypa.io/en/stable/</p> <ul> <li>Specifying packages to process</li> <li>requirements.txt</li> <li>Project metadata</li> <li>Distribution formats</li> <li>Using fetched dependencies</li> <li>Working with Rust-based dependencies</li> <li>Troubleshooting</li> </ul>"},{"location":"pip/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>The \"pip packages\" that Hermeto can process are root directories of Python projects. They should have:</p> <ul> <li>One or more requirements files (unless the project has no dependencies)</li> <li>See what Hermeto requires</li> <li>A file defining the project metadata</li> <li>See what Hermeto supports</li> </ul> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>JSON input:</p> <pre><code>{\n  \"type\": \"pip\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n  // specify requirements files (relative to the package path)\n  // defaults to [\"requirements.txt\"] or [] if the file does not exist\n  \"requirements_files\": [\"requirements.txt\", \"requirements-extra.txt\"],\n  // specify *build* requirements files\n  // defaults to [\"requirements-build.txt\"] or [] if the file does not exist\n  \"requirements_build_files\": [\"requirements-build.txt\"],\n  // option to allow fetching binary distributions (wheels)\n  // defaults to \"false\"\n  \"allow_binary\": \"false\",\n}\n</code></pre> <p>For more information on using build requirements and binary distributions, see Distribution Formats section.</p> <p>The main argument accepts alternative forms of input, see usage: Pre-fetch dependencies.</p>"},{"location":"pip/#requirementstxt","title":"requirements.txt","text":"<p>Hermeto downloads dependencies explicitly declared in lockfiles. For pip, the closest thing to a lockfile would be a \"fully resolved\" requirements.txt - must contain all the transitive dependencies, must pin them to exact versions.</p> <p>A good way to generate requirements.txt is via pip-compile. Note that pip-compile supports reading dependencies directly from project files (e.g. pyproject.toml, setup.cfg, setup.py) or from \"requirements.in\" input files.</p> Example: pyproject.toml <pre><code>[project]\nname = \"my_package\"\nversion = \"0.1.0\"\ndependencies = [\n    \"requests\",\n    \"dockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz\"\n]\n</code></pre> <pre><code>pip-compile pyproject.toml --generate-hashes\n</code></pre> Example: requirements.in <pre><code># requirements.in\nrequests\ndockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz\n</code></pre> <pre><code>pip-compile requirements.in --generate-hashes\n</code></pre> Result: requirements.txt <pre><code>#\n# This file is autogenerated by pip-compile with Python 3.10\n# by the following command:\n#\n#    pip-compile --generate-hashes pyproject.toml\n#\ncertifi==2022.12.7 \\\n    --hash=sha256:35824b4c3a97115964b408844d64aa14db1cc518f6562e8d7261699d1350a9e3 \\\n    --hash=sha256:4ad3232f5e926d6718ec31cfc1fcadfde020920e278684144551c91769c7bc18\n    # via requests\ncharset-normalizer==3.0.1 \\\n    --hash=sha256:00d3ffdaafe92a5dc603cb9bd5111aaa36dfa187c8285c543be562e61b755f6b \\\n    --hash=sha256:024e606be3ed92216e2b6952ed859d86b4cfa52cd5bc5f050e7dc28f9b43ec42 \\\n    --hash=sha256:0298eafff88c99982a4cf66ba2efa1128e4ddaca0b05eec4c456bbc7db691d8d \\\n    --hash=sha256:02a51034802cbf38db3f89c66fb5d2ec57e6fe7ef2f4a44d070a593c3688667b \\\n    --hash=sha256:083c8d17153ecb403e5e1eb76a7ef4babfc2c48d58899c98fcaa04833e7a2f9a \\\n    --hash=sha256:0a11e971ed097d24c534c037d298ad32c6ce81a45736d31e0ff0ad37ab437d59 \\\n    --hash=sha256:0bf2dae5291758b6f84cf923bfaa285632816007db0330002fa1de38bfcb7154 \\\n    --hash=sha256:0c0a590235ccd933d9892c627dec5bc7511ce6ad6c1011fdf5b11363022746c1 \\\n    --hash=sha256:0f438ae3532723fb6ead77e7c604be7c8374094ef4ee2c5e03a3a17f1fca256c \\\n    --hash=sha256:109487860ef6a328f3eec66f2bf78b0b72400280d8f8ea05f69c51644ba6521a \\\n    --hash=sha256:11b53acf2411c3b09e6af37e4b9005cba376c872503c8f28218c7243582df45d \\\n    --hash=sha256:12db3b2c533c23ab812c2b25934f60383361f8a376ae272665f8e48b88e8e1c6 \\\n    --hash=sha256:14e76c0f23218b8f46c4d87018ca2e441535aed3632ca134b10239dfb6dadd6b \\\n    --hash=sha256:16a8663d6e281208d78806dbe14ee9903715361cf81f6d4309944e4d1e59ac5b \\\n    --hash=sha256:292d5e8ba896bbfd6334b096e34bffb56161c81408d6d036a7dfa6929cff8783 \\\n    --hash=sha256:2c03cc56021a4bd59be889c2b9257dae13bf55041a3372d3295416f86b295fb5 \\\n    --hash=sha256:2e396d70bc4ef5325b72b593a72c8979999aa52fb8bcf03f701c1b03e1166918 \\\n    --hash=sha256:2edb64ee7bf1ed524a1da60cdcd2e1f6e2b4f66ef7c077680739f1641f62f555 \\\n    --hash=sha256:31a9ddf4718d10ae04d9b18801bd776693487cbb57d74cc3458a7673f6f34639 \\\n    --hash=sha256:356541bf4381fa35856dafa6a965916e54bed415ad8a24ee6de6e37deccf2786 \\\n    --hash=sha256:358a7c4cb8ba9b46c453b1dd8d9e431452d5249072e4f56cfda3149f6ab1405e \\\n    --hash=sha256:37f8febc8ec50c14f3ec9637505f28e58d4f66752207ea177c1d67df25da5aed \\\n    --hash=sha256:39049da0ffb96c8cbb65cbf5c5f3ca3168990adf3551bd1dee10c48fce8ae820 \\\n    --hash=sha256:39cf9ed17fe3b1bc81f33c9ceb6ce67683ee7526e65fde1447c772afc54a1bb8 \\\n    --hash=sha256:3ae1de54a77dc0d6d5fcf623290af4266412a7c4be0b1ff7444394f03f5c54e3 \\\n    --hash=sha256:3b590df687e3c5ee0deef9fc8c547d81986d9a1b56073d82de008744452d6541 \\\n    --hash=sha256:3e45867f1f2ab0711d60c6c71746ac53537f1684baa699f4f668d4c6f6ce8e14 \\\n    --hash=sha256:3fc1c4a2ffd64890aebdb3f97e1278b0cc72579a08ca4de8cd2c04799a3a22be \\\n    --hash=sha256:4457ea6774b5611f4bed5eaa5df55f70abde42364d498c5134b7ef4c6958e20e \\\n    --hash=sha256:44ba614de5361b3e5278e1241fda3dc1838deed864b50a10d7ce92983797fa76 \\\n    --hash=sha256:4a8fcf28c05c1f6d7e177a9a46a1c52798bfe2ad80681d275b10dcf317deaf0b \\\n    --hash=sha256:4b0d02d7102dd0f997580b51edc4cebcf2ab6397a7edf89f1c73b586c614272c \\\n    --hash=sha256:502218f52498a36d6bf5ea77081844017bf7982cdbe521ad85e64cabee1b608b \\\n    --hash=sha256:503e65837c71b875ecdd733877d852adbc465bd82c768a067badd953bf1bc5a3 \\\n    --hash=sha256:5995f0164fa7df59db4746112fec3f49c461dd6b31b841873443bdb077c13cfc \\\n    --hash=sha256:59e5686dd847347e55dffcc191a96622f016bc0ad89105e24c14e0d6305acbc6 \\\n    --hash=sha256:601f36512f9e28f029d9481bdaf8e89e5148ac5d89cffd3b05cd533eeb423b59 \\\n    --hash=sha256:608862a7bf6957f2333fc54ab4399e405baad0163dc9f8d99cb236816db169d4 \\\n    --hash=sha256:62595ab75873d50d57323a91dd03e6966eb79c41fa834b7a1661ed043b2d404d \\\n    --hash=sha256:70990b9c51340e4044cfc394a81f614f3f90d41397104d226f21e66de668730d \\\n    --hash=sha256:71140351489970dfe5e60fc621ada3e0f41104a5eddaca47a7acb3c1b851d6d3 \\\n    --hash=sha256:72966d1b297c741541ca8cf1223ff262a6febe52481af742036a0b296e35fa5a \\\n    --hash=sha256:74292fc76c905c0ef095fe11e188a32ebd03bc38f3f3e9bcb85e4e6db177b7ea \\\n    --hash=sha256:761e8904c07ad053d285670f36dd94e1b6ab7f16ce62b9805c475b7aa1cffde6 \\\n    --hash=sha256:772b87914ff1152b92a197ef4ea40efe27a378606c39446ded52c8f80f79702e \\\n    --hash=sha256:79909e27e8e4fcc9db4addea88aa63f6423ebb171db091fb4373e3312cb6d603 \\\n    --hash=sha256:7e189e2e1d3ed2f4aebabd2d5b0f931e883676e51c7624826e0a4e5fe8a0bf24 \\\n    --hash=sha256:7eb33a30d75562222b64f569c642ff3dc6689e09adda43a082208397f016c39a \\\n    --hash=sha256:81d6741ab457d14fdedc215516665050f3822d3e56508921cc7239f8c8e66a58 \\\n    --hash=sha256:8499ca8f4502af841f68135133d8258f7b32a53a1d594aa98cc52013fff55678 \\\n    --hash=sha256:84c3990934bae40ea69a82034912ffe5a62c60bbf6ec5bc9691419641d7d5c9a \\\n    --hash=sha256:87701167f2a5c930b403e9756fab1d31d4d4da52856143b609e30a1ce7160f3c \\\n    --hash=sha256:88600c72ef7587fe1708fd242b385b6ed4b8904976d5da0893e31df8b3480cb6 \\\n    --hash=sha256:8ac7b6a045b814cf0c47f3623d21ebd88b3e8cf216a14790b455ea7ff0135d18 \\\n    --hash=sha256:8b8af03d2e37866d023ad0ddea594edefc31e827fee64f8de5611a1dbc373174 \\\n    --hash=sha256:8c7fe7afa480e3e82eed58e0ca89f751cd14d767638e2550c77a92a9e749c317 \\\n    --hash=sha256:8eade758719add78ec36dc13201483f8e9b5d940329285edcd5f70c0a9edbd7f \\\n    --hash=sha256:911d8a40b2bef5b8bbae2e36a0b103f142ac53557ab421dc16ac4aafee6f53dc \\\n    --hash=sha256:93ad6d87ac18e2a90b0fe89df7c65263b9a99a0eb98f0a3d2e079f12a0735837 \\\n    --hash=sha256:95dea361dd73757c6f1c0a1480ac499952c16ac83f7f5f4f84f0658a01b8ef41 \\\n    --hash=sha256:9ab77acb98eba3fd2a85cd160851816bfce6871d944d885febf012713f06659c \\\n    --hash=sha256:9cb3032517f1627cc012dbc80a8ec976ae76d93ea2b5feaa9d2a5b8882597579 \\\n    --hash=sha256:9cf4e8ad252f7c38dd1f676b46514f92dc0ebeb0db5552f5f403509705e24753 \\\n    --hash=sha256:9d9153257a3f70d5f69edf2325357251ed20f772b12e593f3b3377b5f78e7ef8 \\\n    --hash=sha256:a152f5f33d64a6be73f1d30c9cc82dfc73cec6477ec268e7c6e4c7d23c2d2291 \\\n    --hash=sha256:a16418ecf1329f71df119e8a65f3aa68004a3f9383821edcb20f0702934d8087 \\\n    --hash=sha256:a60332922359f920193b1d4826953c507a877b523b2395ad7bc716ddd386d866 \\\n    --hash=sha256:a8d0fc946c784ff7f7c3742310cc8a57c5c6dc31631269876a88b809dbeff3d3 \\\n    --hash=sha256:ab5de034a886f616a5668aa5d098af2b5385ed70142090e2a31bcbd0af0fdb3d \\\n    --hash=sha256:c22d3fe05ce11d3671297dc8973267daa0f938b93ec716e12e0f6dee81591dc1 \\\n    --hash=sha256:c2ac1b08635a8cd4e0cbeaf6f5e922085908d48eb05d44c5ae9eabab148512ca \\\n    --hash=sha256:c512accbd6ff0270939b9ac214b84fb5ada5f0409c44298361b2f5e13f9aed9e \\\n    --hash=sha256:c75ffc45f25324e68ab238cb4b5c0a38cd1c3d7f1fb1f72b5541de469e2247db \\\n    --hash=sha256:c95a03c79bbe30eec3ec2b7f076074f4281526724c8685a42872974ef4d36b72 \\\n    --hash=sha256:cadaeaba78750d58d3cc6ac4d1fd867da6fc73c88156b7a3212a3cd4819d679d \\\n    --hash=sha256:cd6056167405314a4dc3c173943f11249fa0f1b204f8b51ed4bde1a9cd1834dc \\\n    --hash=sha256:db72b07027db150f468fbada4d85b3b2729a3db39178abf5c543b784c1254539 \\\n    --hash=sha256:df2c707231459e8a4028eabcd3cfc827befd635b3ef72eada84ab13b52e1574d \\\n    --hash=sha256:e62164b50f84e20601c1ff8eb55620d2ad25fb81b59e3cd776a1902527a788af \\\n    --hash=sha256:e696f0dd336161fca9adbb846875d40752e6eba585843c768935ba5c9960722b \\\n    --hash=sha256:eaa379fcd227ca235d04152ca6704c7cb55564116f8bc52545ff357628e10602 \\\n    --hash=sha256:ebea339af930f8ca5d7a699b921106c6e29c617fe9606fa7baa043c1cdae326f \\\n    --hash=sha256:f4c39b0e3eac288fedc2b43055cfc2ca7a60362d0e5e87a637beac5d801ef478 \\\n    --hash=sha256:f5057856d21e7586765171eac8b9fc3f7d44ef39425f85dbcccb13b3ebea806c \\\n    --hash=sha256:f6f45710b4459401609ebebdbcfb34515da4fc2aa886f95107f556ac69a9147e \\\n    --hash=sha256:f97e83fa6c25693c7a35de154681fcc257c1c41b38beb0304b9c4d2d9e164479 \\\n    --hash=sha256:f9d0c5c045a3ca9bedfc35dca8526798eb91a07aa7a2c0fee134c6c6f321cbd7 \\\n    --hash=sha256:ff6f3db31555657f3163b15a6b7c6938d08df7adbfc9dd13d9d19edad678f1e8\n    # via requests\ndockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz \\\n    --hash=sha256:36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d\n    # via my-package (pyproject.toml)\nidna==3.4 \\\n    --hash=sha256:814f528e8dead7d329833b91c5faa87d60bf71824cd12a7530b5526063d02cb4 \\\n    --hash=sha256:90b77e79eaa3eba6de819a0c442c0b4ceefc341a7a2ab77d7562bf49f425c5c2\n    # via requests\nrequests==2.28.2 \\\n    --hash=sha256:64299f4909223da747622c030b781c0d7811e359c37124b4bd368fb8c6518baa \\\n    --hash=sha256:98b1b2782e3c6c4904938b84c0eb932721069dfdb9134313beff7c83c2df24bf\n    # via my-package (pyproject.toml)\nurllib3==1.26.14 \\\n    --hash=sha256:076907bf8fd355cde77728471316625a4d2f7e713c125f51953bb5b3eecf4f72 \\\n    --hash=sha256:75edcdc2f7d85b137124a6c3c9fc3933cdeaa12ecb9a6a959f22797a0feca7e1\n    # via requests\n</code></pre>"},{"location":"pip/#hashes","title":"Hashes","text":"<p>https://pip.pypa.io/en/stable/topics/secure-installs/#hash-checking-mode</p> <p>Using hashes is strongly recommended.</p> <p>If using pip-compile, use the <code>--generate-hashes</code> option.</p>"},{"location":"pip/#external-dependencies","title":"External dependencies","text":"<p>For dependencies coming from somewhere other than PyPI, Hermeto supports a subset of the PEP 440 direct references.</p>"},{"location":"pip/#https-urls","title":"https urls","text":"<pre><code>dockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz \\\n    --hash=sha256:36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d\n</code></pre> <p>For https dependencies, Hermeto requires exactly one --hash option as protection from remote tampering.</p> <p>Note that if at least one dependency in your requirements file uses --hash, pip requires hashes for all dependencies. Use <code>pip-compile --generate-hashes</code> to generate compliant requirements files.</p> <p>Hermeto does not support PEP 440 hashes in the url fragment, only --hash options.</p>"},{"location":"pip/#git-urls","title":"git urls","text":"<pre><code>dockerfile-parse @ git+https://github.com/containerbuildsystem/dockerfile-parse@b6230230987950cfb16d8858c6f9a9642f4d0952\n</code></pre> <p>Git dependencies are incompatible with pip's hash checking. Please use an https url instead, if possible:</p> <pre><code>- dockerfile-parse @ git+https://github.com/containerbuildsystem/dockerfile-parse@b6230230987950cfb16d8858c6f9a9642f4d0952\n+ dockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz \\\n+     --hash=sha256:36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d\n</code></pre> <p>If you do need to use a git url, Hermeto requires that it specifies a full commit hash.</p> <p>Hermeto does not support PEP 440 commit hashes in the url fragment (the <code>#</code> part), only directly after <code>@</code>.</p> <p>Note: it's impossible to craft a requirements.txt file that would download dependencies from both https urls and git urls. Hermeto requires hashes for https. Using one --hash makes pip require hashes for everything. Pip does not support hashes for git dependencies. Please use https urls instead.</p>"},{"location":"pip/#supported-options","title":"Supported options","text":"<p>Requirements files support some <code>pip install</code> options - see https://pip.pypa.io/en/stable/reference/requirements-file-format/#supported-options.</p> <p>Hermeto supports a small subset of them, ignores those that are not relevant for prefetching, and raises an error for those that are relevant but aren't supported.</p>"},{"location":"pip/#global","title":"Global","text":""},{"location":"pip/#-index-url","title":"<code>--index-url</code>","text":"<p>Supported since v0.8.0.</p> <p>Make Hermeto download packages from the specified Python Package Index server.</p> <p>Note: applies to all the packages (and only the packages) from the file which contains the <code>--index-url</code> option. If file A contains <code>--index-url</code> and file B does not, Hermeto will download the packages declared in B from the default index server (https://pypi.org/simple/).</p> <p>:warning: Do not include credentials in the index url. If needed, provide authentication via a <code>.netrc</code> file: https://pip.pypa.io/en/stable/topics/authentication/#netrc-support</p>"},{"location":"pip/#-require-hashes","title":"<code>--require-hashes</code>","text":"<p>Enables hash-checking mode. Typically redundant, since the presence of any <code>--hash</code> option enables hash-checking mode as well.</p>"},{"location":"pip/#-trusted-host","title":"<code>--trusted-host</code>","text":"<p>Disables HTTPS validation for a host. Don't use this for production builds.</p>"},{"location":"pip/#per-requirement","title":"Per-requirement","text":""},{"location":"pip/#-hash","title":"<code>--hash</code>","text":"<p>Specifies the expected hashes for package archives. See also the hashes section.</p>"},{"location":"pip/#project-metadata","title":"Project metadata","text":"<p>Hermeto looks for the name and version of your project in the following project files:</p> <ul> <li>pyproject.toml</li> <li>setup.cfg</li> <li>setup.py</li> </ul> <p>If Hermeto fails to resolve the project name, it will generate a name based on the git repository origin url (and package subpath if the package is not in the repository root). If Hermeto fails to resolve the version, it will omit the version.</p>"},{"location":"pip/#pyprojecttoml-pep-621-metadata","title":"pyproject.toml: PEP 621 metadata","text":"<p>Supported cases:</p> <pre><code>[project]\nname = \"my_package\"\nversion = \"0.1.0\"\n</code></pre> <p>Unsupported cases:</p> <pre><code>[project]\nname = \"my_package\"\ndynamic = [\"version\"]\n</code></pre>"},{"location":"pip/#setupcfg","title":"setup.cfg","text":"<p>Supported cases:</p> <pre><code>[metadata]\nname = my_package\nversion = 0.1.0\n</code></pre> <pre><code>[metadata]\nname = my_package\nversion = file: VERSION\n# taken from ./VERSION\n# example content:\n#   0.1.0\n</code></pre> <pre><code>[metadata]\nname = my_package\nversion = attr: my_package.VERSION\n# taken from my_package/__init__.py or my_package.py\n# example content:\n#   VERSION = \"0.1.0\"\n</code></pre> <p>Unsupported cases:</p> <ul> <li>missing <code>version</code></li> <li>some forms of <code>version = attr:</code> (those that would require executing the module)</li> </ul>"},{"location":"pip/#setuppy","title":"setup.py","text":"<p>Using setup.py is discouraged.</p> <p>Supported cases:</p> <pre><code>setup(name=\"my_package\", version=\"0.1.0\", ...)\n</code></pre> <pre><code># basic variable usage is supported\nNAME = \"my_package\"\nVERSION = \"0.1.0\"\n\nif __name__ == \"__main__\":\n    # setup() call can be anywhere in the file\n    setup(name=NAME, version=VERSION, ...)\n</code></pre>"},{"location":"pip/#distribution-formats","title":"Distribution formats","text":"<p>Python packages typically distribute both the binary format (called wheel) and the source format (called sdist).</p> <p>Wheels are much more convenient; they are the pre-built format, installing from a wheel amounts to unzipping the wheel and copying the files to the right place.</p> <p>Sdists are more difficult to install. Pip must first build a wheel from the sdist using a PEP 517 build system. To do that, pip has to install the build system and its dependencies (defined via PEP 518).</p> <p>Hermeto (unlike the older Cachito) can download both wheels and sdists. The <code>allow_binary</code> option controls this behavior.</p> <ul> <li><code>\"allow_binary\": \"true\"</code> - download both wheels and sdists</li> <li><code>\"allow_binary\": \"false\"</code> - download only sdists (default)</li> </ul> <p>Note: Hermeto currently downloads one sdist and all the available wheels per dependency (no filtering is being made by platform or Python version).</p>"},{"location":"pip/#building-with-wheels","title":"Building with wheels","text":"<p>Pre-fetching and building with wheels is much easier and faster than pre-fetching and building from source (even without filtering of wheels). However, downloading all the wheels naturally results in a much larger overall download size. Based on sample testing, wheels + sdists will be approximately 5x to 15x larger than just the sdists. When building with wheels, dealing with build dependencies via requirements-build.txt is unnecessary.</p>"},{"location":"pip/#building-from-source","title":"Building from source","text":"<p>Building wheels from sdists takes a long time, but building from source gives you an important guarantee which using pre-built wheels does not: what you installed matches the source code. This can be especially important for Python packages implemented in C or other compiled languages.</p>"},{"location":"pip/#requirements-buildtxt","title":"requirements-build.txt","text":"<p>To allow building from source in a network-isolated environment, Hermeto must download all the PEP 517 build dependencies before the build starts.</p> <p>Hermeto requires a fully resolved requirements-build.txt to do this. The file follows the same rules as requirements.txt, but contains build dependencies rather than runtime dependencies.</p> <p>Note: this file must contain all the transitive build dependencies of each of your transitive runtime dependencies (you are installing dependencies from source).</p> <p>We recommend the pybuild-deps package to generate the requirements-build.txt file. It will automatically generate build requirements from your requirements.txt file.</p> <p>Adding a requirements-build.txt should not require changes in your build process. Pip should install the build dependencies automatically as needed, you don't have to install them explicitly. The purpose of requirements-build.txt is to make Hermeto fetch the build dependencies and provide them to pip for offline installation.</p>"},{"location":"pip/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See also usage.md for a complete example of Hermeto usage.</p> <p>Hermeto downloads the Python dependencies into the deps/pip/ subpath of the output directory. The directory is a flat list of the downloaded distributions of your runtime and build dependencies.</p> <pre><code>hermeto-output/deps/pip\n\u251c\u2500\u2500 certifi-2022.12.7.tar.gz\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 pdm-pep517-1.0.6.tar.gz\n\u251c\u2500\u2500 requests-2.28.2.tar.gz\n\u251c\u2500\u2500 ...\n\u2514\u2500\u2500 wheel-0.38.4.tar.gz\n</code></pre> <p>To make pip use the downloaded archives, use the --find-links and --no-index options. The --find-links option tells pip to look for dependency archives in a directory, --no-index prevents pip from preferring PyPI over the local directory. Pip also accepts environment variables; Hermeto generates <code>PIP_FIND_LINKS</code> and <code>PIP_NO_INDEX</code> for you. See usage: generate environment variables for more details.</p>"},{"location":"pip/#using-external-dependencies","title":"Using external dependencies","text":"<p>It gets a bit trickier with external dependencies. Pip does not respect the --find-links option for dependencies specified via urls. Instead, Hermeto rewrites your requirements.txt file(s) in place to replace the urls with file paths (after you call the hermeto inject-files subcommand).</p> <pre><code>- dockerfile-parse @ https://github.com/.../2.0.0.tar.gz \\\n+ dockerfile-parse @ file:///absolute-path/hermeto-output/deps/pip/.../dockerfile-parse-...tar.gz\n</code></pre> <p>External dependencies are stored a bit further down the deps/pip tree to avoid mixing them with PyPI dependencies. The path and filename is an implementation detail.</p> <pre><code>hermeto-output/deps/pip\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 external-dockerfile-parse\n\u2502   \u2514\u2500\u2500 dockerfile-parse-external-sha256-36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d.tar.gz\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"pip/#working-with-rust-based-dependencies","title":"Working with Rust-based dependencies","text":"<p>Hermeto provides a way to prepare hermetic build of a Python package which depends on Rust-based packages. This process cannot be fully automated on Hermeto's side, thus it would require minor intervention from users.</p> <p>Building such project requires that all build dependencies are  listed in requirements-build.txt. To achieve this pybuild-deps could be used. The following command will take care of generating the list:</p> <pre><code>pybuild-deps compile --generate-hashes -o requirements-build.txt requirements.txt\n</code></pre> <p>Note, that this step requires internet connection.</p> <p>Once requirements-build.txt is populated fetch could be done as usual. Hermeto will fetch all run time and build time dependencies for both Python and Rust parts.</p> <p>Note, that a system which is to be used for building these extensions must have <code>rustc</code>, <code>cargo</code>, and all necessary C libraries installed.</p> <p>With these preparations running a pip installation as usual should be sufficient to build and install a Rust-based extension.</p> <p>Note, that sometimes Rust-based extensions can break a build. This could happen when such dependency is distributed with a Cargo.lock not matching Cargo.toml (while rare this seems to happen due to peculiarities of the release process for some packages). In this case a package will be rejected with a note about lock file mismatch and an additional report from Cargo about inability to load package lock file due to a mismatch. There is no good solution for this problem on Hermeto's side and the best course of action is to reach out to maintainers of this extension and notify them about the mismatch. Switching to a binary distribution of the package would also resolve this problem at the price of not building it from sources (see Building with wheels for additional context).</p>"},{"location":"pip/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues you may face when fetching dependencies or when installing the fetched dependencies.</p> <p>First, please make sure that your project meets Hermeto's requirements (this document) and that you are using Hermeto as intended (usage.md).</p>"},{"location":"pip/#miscellaneous-errors-while-building-from-source","title":"Miscellaneous errors while building from source","text":"<p>Have you read Building from source?</p> <p>Even if you have all the build dependencies available, installing from source can come with unforeseen complications. Pip's --no-binary flag can help debug faster.</p> <pre><code># on your machine\nvirtualenv venv &amp;&amp; source venv/bin/activate\n# or in a container\npodman run --rm -ti -v \"$PWD:$PWD:z\" -w \"$PWD\" ubi8/python-39 bash\n\npip install --no-binary :all: -r requirements.txt\n</code></pre> <p>Notably, older versions of pip and setuptools have a fair share of bugs related to PEP 517 handling. A good first course of action can be to upgrade pip and setuptools and try again.</p> <p>Other pip install options such as --use-pep517 may also be of interest.</p>"},{"location":"pip/#need-to-install-newer-pip","title":"Need to install newer pip","text":"<p>Problem: you've found out that some build errors are caused by bugs in an older pip version. But the base image for your container build comes with <code>pip==&lt;old&gt;</code> and you cannot upgrade during the build because you're building with network isolation.</p> <p>Solution: make Hermeto fetch a newer pip for you. Then you can upgrade pip from the prefetched archive.</p> <pre><code># add to requirements-build.txt or use a separate file\npip==22.3.1 --hash=...\n</code></pre> <pre><code>RUN source /tmp/hermeto.env &amp;&amp; \\\n    pip install -U pip &amp;&amp; \\\n    pip install .\n</code></pre> <p>You can use a similar approach to upgrade setuptools or other build dependencies before installing your app. Build dependencies other than pip should be part or requirements-build.txt already.</p>"},{"location":"pip/#failing-to-compile-a-dependency","title":"Failing to compile a dependency","text":"<p>Building dependencies written in C typically requires gcc, CPython headers and other development libraries. Hermeto does not fetch these, getting them into the build is up to you. The best case scenario, if you're building a container, is that the base image already contains everything you need. For example, the ubi8/python-39 image contains most of the typical development libraries.</p> <p>To find out what non-Python dependencies you need, try to <code>pip install --no-binary :all:</code> in a clean environment (e.g. a container) as shown above. The error messages you get should hopefully point you to the required dependencies.</p> <p>For dependencies compiled from other languages, such as Rust, we don't know of any good solutions for offline installation. If you do manage to make it work, please let us know.</p>"},{"location":"pip/#dependency-does-not-distribute-sources","title":"Dependency does not distribute sources","text":"<p>Some projects do not distribute sdists to PyPI. For example, tensorflow (as of version 2.11.0) distributes only wheels.</p> <p>Possible workarounds:</p> <ul> <li>Enable pre-fetching wheels using <code>\"allow_binary\": \"true\"</code> in JSON input.</li> <li>Find the git repository for the project, get the source tarball for a release. In requirements.txt, specify the dependency via an https url.</li> </ul> <pre><code>- tensorflow==2.11.0\n+ tensorflow @ https://github.com/tensorflow/tensorflow/archive/refs/tags/v2.11.0.tar.gz \\\n+     --hash=sha256:99c732b92b1b37fc243a559e02f9aef5671771e272758aa4aec7f34dc92dac48\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>This document is split into two general sections. The first goes through the general process of pre-fetching dependencies and injecting relevant configuration and content for building an application in a hermetic environment. The second section goes through each of these steps for the supported package managers.</p> <ul> <li>General Process</li> <li>pre-fetch dependencies</li> <li>generate environment variables</li> <li>inject project files</li> <li>merge SBOMs</li> <li>building the artifact<ul> <li>set the environment variables (Containerfile example)</li> <li>run the build (container build example)</li> </ul> </li> <li>Usage Examples</li> <li>Example with Go modules</li> <li>Example with pip</li> <li>Example with npm</li> <li>Example with yarn</li> <li>Example with generic fetcher</li> </ul>"},{"location":"usage/#general-process","title":"General Process","text":"<p>A hermetic build environment is one that is fully encapsulated and isolated from outside influences. When a build is run on a build platform, this encapsulation can guarantee that the platform has a complete picture of all dependencies needed for the build. One class of hermetic build implementations is to restrict external network access during the build itself, requiring that all dependencies are declared and pre-fetched before the build occurs.</p> <p>In order to support this class of hermetic builds, not only does Hermeto need to pre-fetch the dependencies, but some build flows will need additional changes (i.e. leveraging defined environment variables or using Hermeto to inject project files).</p> <p>Hermeto relies on git metadata when processing sources, it expects sources to be a valid git repository with \"origin\" remote defined. This is paramount for successful execution. If for some reason you don't have a git repository, e.g. you're trying to use Hermeto on an unpacked tarball, you may also get acceptable results by forcefully creating a git repository from it first. Make sure to set the remote as well.</p> Workaround to create a local-only git repository    ```shell   git init &amp;&amp; git add -A &amp;&amp; git commit -m \"initial commit\" &amp;&amp; \\   git remote add origin https://github.com/someorg/somerepo   ```   **WARNING!** This is not a substitute for having a proper repository and should be used   only for testing!  <p>Note however, that this is only good for smoke testing a scenario and there are no guarantees for any results without proper and correct git metadata, e.g. git tags.</p>"},{"location":"usage/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>The first step in creating hermetic builds is to fetch the dependencies for one of the supported package managers.</p> <pre><code>hermeto fetch-deps \\\n  --source ./foo \\\n  --output ./hermeto-output \\\n  --sbom-output-type cyclonedx \\\n  '{\"path\": \".\", \"type\": \"&lt;supported package manager&gt;\"}'\n</code></pre> <ul> <li><code>--source</code>           - the path to a git repository on the local disk <code>[default: .]</code></li> <li><code>--output</code>           - the path to the directory where Hermeto will write all output <code>[default: ./hermeto-output]</code></li> <li><code>--sbom-output-type</code> - the format of generated SBOM, supported values are <code>cyclonedx</code> (outputs CycloneDX v1.4) and <code>spdx</code> (outputs SPDX v2.3). <code>[default: cyclonedx]</code></li> <li><code>{JSON}</code>             - specifies a package (a directory) within the repository to process</li> </ul> <p>Note that Hermeto does not auto-detect which package managers your project uses. You need to tell Hermeto what to process when calling fetch-deps. In the example above, the package path is located at the root of the foo repo, hence the relative path is <code>.</code>.</p> <p>The main parameter (PKG) can handle different types of definitions:</p> <ul> <li>simple: <code>&lt;package manager&gt;</code>, same as <code>{\"path\": \".\", \"type\": \"&lt;package manager&gt;\"}</code></li> <li>JSON object: <code>{\"path\": \"subpath/to/other/module\", \"type\": \"&lt;package manager&gt;\"}</code></li> <li>JSON array: <code>[{\"path\": \".\", \"type\": \"&lt;package manager&gt;\"}, {\"path\": \"subpath/to/other/module\", \"type\": \"&lt;package manager&gt;\"}]</code></li> <li>JSON object with flags: <code>{\"packages\": [{\"path\": \".\", \"type\": \"&lt;package manager&gt;\"}], \"flags\": [\"cgo-disable\"]}</code></li> </ul> <p>See also <code>hermeto fetch-deps --help</code>.</p> <p>Using the JSON array object, multiple package managers can be used to resolve dependencies in the same repository.</p> <p>\u26a0 While Hermeto does not intentionally modify the source repository unless the output and source paths are the same, some package managers may add missing data like checksums as dependency data is resolved. If this occurs from a clean git tree then the tree has the possibility to become dirty.</p>"},{"location":"usage/#generate-environment-variables","title":"Generate environment variables","text":"<p>Once the dependencies have been cached, the build process needs to be made aware of the dependencies. Some package managers need to be informed of cache customizations by environment variables.</p> <p>In order to simplify this process, Hermeto provides a helper command to generate the environment variables in an easy-to-use format. The example above uses the \"env\" format which generates a simple shell script that <code>export</code>s the required variables (properly shell quoted when necessary). You can <code>source</code> this file to set the variables.</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <ul> <li><code>-o</code> - the output path for the generated environment file</li> </ul> <p>Don't worry about the <code>--for-output-dir</code> option yet - and about the fact that the directory does not exist - it has to do with the target path where we will mount the output directory during the build.</p> <p>See also <code>hermeto generate-env --help</code>.</p>"},{"location":"usage/#inject-project-files","title":"Inject project files","text":"<p>While some package managers only need an environment file to be informed of the cache locations, others may need to create a configuration file or edit a lockfile (or some other file in your project directory).</p> <p>Before starting your build, call <code>hermeto inject-files</code> to automatically make the necessary changes in your repository (based on data in the fetch-deps output directory). Please do not change the absolute path to the repo between the calls to fetch-deps and inject-files; if it's not at the same path, the inject-files command won't find it.</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre> <p>The <code>--for-output-dir</code> option has the same meaning as the one used when generating environment variables.</p> <p>\u26a0 Hermeto may overwrite existing files. Please make sure you have no un-committed changes (that you are not prepared to lose) when calling inject-files.</p> <p>\u26a0 Hermeto may change files if required by the package manager. This means that the git status will become dirty if it was previously clean. If any scripting depends on the cleanliness of a git repository and you do not want to commit the changes, the scripting should either be changed to handle the dirty status or the changes should be temporarily stashed by wrapping in <code>git stash &amp;&amp; &lt;command&gt; &amp;&amp; git stash pop</code> according to the suitability of the context.</p>"},{"location":"usage/#merge-sboms","title":"Merge SBOMs","text":"<p>Sometimes it might be necessary to merge two or more SBOMs. This could be done with <code>hermeto merge-sboms</code>:</p> <pre><code>hermeto merge-sboms &lt;hermeto_sbom_1.json&gt; ... &lt;hermeto_sbom_n.json&gt;\n</code></pre> <p>The subcommand expects at least two SBOMs, all produced by Hermeto, and will exit with error otherwise. The reason for this is that Hermeto supports a limited set of component properties, and it validates that no other properties exist in the SBOM. By default the result of a merge will be printed to stdout. To save it to a file use <code>-o</code> option:</p> <pre><code>hermeto merge-sboms &lt;hermeto_sbom_1.json&gt; ... &lt;hermeto_sbom_n.json&gt; -o &lt;merged_sbom.json&gt;\n</code></pre>"},{"location":"usage/#building-the-artifact-with-the-pre-fetched-dependencies","title":"Building the Artifact with the Pre-fetched dependencies","text":"<p>After the pre-fetch and the above steps to inform the package manager(s) of the cache have been completed, it all needs to be wired up into a build. The primary use case for building these is within a Dockerfile or Containerfile but the same principles can be applied to other build strategies.</p>"},{"location":"usage/#write-the-dockerfile-or-containerfile","title":"Write the Dockerfile (or Containerfile)","text":"<p>Now that we have pre-fetched our dependencies and enabled package manager configuration to point to them, we now need to ensure that the build process (i.e. a Dockerfile or Containerfile for a container build) is properly written to build in a network isolated mode. All injected files are changed in the source itself, so they will be present in the build context for the Containerfile. The environment variables added to the <code>hermeto.env</code> file, however, will not be pulled into the build process without a specific action to <code>source</code> the generated file.</p> <p>Outside of this additional <code>source</code> directive in any relevant <code>RUN</code> command, the rest of a container build can remain unchanged.</p> <pre><code>FROM golang:1.19.2-alpine3.16 AS build\n\nCOPY ./foo /src/foo\nWORKDIR /src/foo\n\nRUN source /tmp/hermeto.env &amp;&amp; \\\n    make build\n\nFROM registry.access.redhat.com/ubi9/ubi-minimal:9.0.0\n\nCOPY --from=build /foo /usr/bin/foo\n</code></pre> <p>\u26a0 The <code>source</code>d environment variables do not persist to the next RUN instruction. The sourcing of the file and the package manager command(s) need to be in the same instruction. If the build needs more than one command and you would like to split them into separate RUN instructions, <code>source</code> the environment file in each one.</p> <pre><code>RUN source /tmp/hermeto.env &amp;&amp; \\\n    go build -o /foo cmd/foo &amp;&amp; \\\n    go build -o /bar cmd/bar\n\n# or, if preferrable\nRUN source /tmp/hermeto.env &amp;&amp; go build -o /foo cmd/foo\nRUN source /tmp/hermeto.env &amp;&amp; go build -o /bar cmd/bar\n</code></pre>"},{"location":"usage/#build-the-container","title":"Build the container","text":"<p>Now that the Dockerfile or Container file is configured, the next step is to build the container itself. Since more than just the source code context is needed to build the container, we also need to make sure that there are appropriate volumes mounted for the Hermeto output as well as the Hermeto environment variable that is being <code>source</code>d within the build. Since all dependencies are cached, we can confidently restrict the network from the container build as well!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag foo\n\n# test that it worked\npodman run --rm -ti foo\n</code></pre> <p>We use the <code>--volume</code> option to mount Hermeto resources into the container build - the output directory at /tmp/hermeto-output/ and the environment file at /tmp/hermeto.env.</p> <p>The path where the output directory gets mounted is important. Some environment variables or project files may use absolute paths to content in the output directory; if the directory is not at the expected path, the paths will be wrong. Remember the <code>--for-output-dir</code> option used when generating the env file and injecting the project files? The absolute path to ./hermeto-output on your machine is (probably) not /tmp/hermeto-output. That is why we had to tell the generate-env command what the path inside the container is eventually going to be.</p> <p>In order to run the build with network isolation, use the <code>--network=none</code> option. Note that this option only works if your podman/buildah version contains the fix for buildah#4227 (buildah &gt;= 1.28). In older versions, a workaround could be to manually create an internal network (but you'll need root privileges): <code>sudo podman network create --internal isolated-network; sudo podman build --network isolated-network ...</code>.</p>"},{"location":"usage/#usage-examples","title":"Usage Examples","text":"<p>Now that we are familiar with the overall process, we will go through an example for each of the supported package managers.</p>"},{"location":"usage/#example-go-modules","title":"Example: Go modules","text":"<p>Let's show Hermeto usage by building the glorious fzf CLI tool hermetically. To follow along, clone the repository to your local disk.</p> <pre><code>git clone https://github.com/junegunn/fzf --branch=0.34.0\n</code></pre>"},{"location":"usage/#pre-fetch-dependencies_1","title":"Pre-fetch dependencies","text":"<p>In order to pre-fetch the dependencies, we will pass the source and output directories as well as the path for the <code>gomod</code> package manager to be able to find the <code>go.mod</code> file.</p> <p>See the gomod documentation for more details about running Hermeto for pre-fetching gomod dependencies.</p> <pre><code>hermeto fetch-deps \\\n  --source ./fzf \\\n  --output ./hermeto-output \\\n  '{\"path\": \".\", \"type\": \"gomod\"}'\n</code></pre>"},{"location":"usage/#generate-environment-variables_1","title":"Generate environment variables","text":"<p>Next, we need to generate the environment file so that the <code>go build</code> command can find the cached dependencies</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <p>We can see the variables needed by the compiler:</p> <pre><code>$ cat hermeto.env\nexport GOCACHE=/tmp/hermeto-output/deps/gomod\nexport GOMODCACHE=/tmp/hermeto-output/deps/gomod/pkg/mod\nexport GOPATH=/tmp/hermeto-output/deps/gomod\n</code></pre>"},{"location":"usage/#inject-project-files_1","title":"Inject project files","text":"<p>While the <code>gomod</code> package manager does not currently need to modify any content in the source directory to inject the dependencies, the <code>inject-files</code> command should be run to ensure that the operation is performed if this step becomes a requirement in the future.</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre>"},{"location":"usage/#write-the-dockerfile-or-containerfile_1","title":"Write the Dockerfile (or Containerfile)","text":"<p>As mentioned in the steps above, the only change that needs to be made in the Dockerfile or Containerfile is to source the environment file before building the binary.</p> <pre><code>FROM golang:1.19.2-alpine3.16 AS build\n\nCOPY ./fzf /src/fzf\nWORKDIR /src/fzf\n\nRUN source /tmp/hermeto.env &amp;&amp; \\\n    go build -o /fzf\n\nFROM registry.access.redhat.com/ubi9/ubi-minimal:9.0.0\n\nCOPY --from=build /fzf /usr/bin/fzf\n\nCMD ls | fzf\n</code></pre>"},{"location":"usage/#build-the-container_1","title":"Build the container","text":"<p>Finally, we can build and test the container to ensure that we have successfully built the binary.</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag fzf\n\n# test that it worked\npodman run --rm -ti fzf\n</code></pre>"},{"location":"usage/#example-pip","title":"Example: pip","text":"<p>Let's build atomic-reactor. Atomic-reactor already builds with Cachito (Hermeto's spiritual ancestor), which makes it a rare example of a Python project that meets Hermeto's requirements out of the box (see pip.md for more context).</p> <p>Get the repo if you want to try for yourself:</p> <pre><code>git clone https://github.com/containerbuildsystem/atomic-reactor --branch=4.4.0\n</code></pre>"},{"location":"usage/#pre-fetch-dependencies-pip","title":"Pre-fetch dependencies (pip)","text":"<p>The steps for pre-fetching the dependencies is similar to before, but this time we will use the <code>pip</code> package manager type. The default behavior path of <code>.</code> is assumed. Additional parameters are also configured to point Hermeto at the various requirements files that are needed to fully resolve dependencies.</p> <p>See the pip documentation for more details about running Hermeto for pre-fetching pip dependencies.</p> <pre><code>hermeto fetch-deps --source ./atomic-reactor '{\n  \"type\": \"pip\",\n  \"requirements_files\": [\"requirements.txt\"],\n  \"requirements_build_files\": [\"requirements-build.txt\", \"requirements-pip.txt\"]\n}'\n</code></pre>"},{"location":"usage/#generate-environment-variables-pip","title":"Generate environment variables (pip)","text":"<p>Next, we need to generate the environment file so that the <code>pip install</code> command can find the cached dependencies</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <p>We can see the variables needed by the package manager:</p> <pre><code>$ cat hermeto.env\nexport PIP_FIND_LINKS=/tmp/hermeto-output/deps/pip\nexport PIP_NO_INDEX=true\n</code></pre>"},{"location":"usage/#inject-project-files-pip","title":"Inject project files (pip)","text":"<p>In order to be able to install pip dependencies in a hermetic environment, we need to perform the injection to change the remote dependencies to instead point to the local file system.</p> <pre><code>$ hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n2023-01-26 16:41:09,990 INFO Overwriting /tmp/test/atomic-reactor/requirements.txt\n</code></pre> <p>We can look at the <code>git diff</code> to see what the package remapping looks like. As an example,</p> <pre><code>diff --git a/requirements.txt b/requirements.txt\n-osbs-client @ git+https://github.com/containerbuildsystem/osbs-client@8d7d7fadff38c8367796e6ac0b3516b65483db24\n-    # via -r requirements.in\n+osbs-client @ file:///tmp/hermeto-output/deps/pip/github.com/containerbuildsystem/osbs-client/osbs-client-external-gitcommit-8d7d7fadff38c8367796e6ac0b3516b65483db24.tar.gz\n</code></pre> <p>\u26a0 This is only needed for external dependencies. If all dependencies come from PyPi, Hermeto will not replace anything.</p>"},{"location":"usage/#build-the-base-image-pip","title":"Build the base image (pip)","text":"<p>For this example, we will split the build into two parts - a base image and the final application image. Since there is no way to install RPMs in a hermetic environment, we will create the base image with its required \"devel\" libraries from RPMs in one image and then use that image for our hermetic python build.</p> <p>If your project doesn't need to compile as many C packages as atomic-reactor, you may be able to find a base image that already contains everything you need.</p> <p>Containerfile.baseimage:</p> <pre><code>FROM quay.io/centos/centos:stream8\n\n# python3.8 runtime, C build dependencies\nRUN dnf -y install \\\n        python38 \\\n        python38-pip \\\n        python38-devel \\\n        gcc \\\n        make \\\n        libffi-devel \\\n        krb5-devel \\\n        cairo-devel \\\n        cairo-gobject-devel \\\n        gobject-introspection-devel \\\n        openssl-devel &amp;&amp; \\\n    dnf clean all\n</code></pre> <p>This container build might be what we are familiar with already as we are not using Hermeto or enforcing network isolation.</p> <pre><code>podman build . -f Containerfile.baseimage --tag atomic-reactor-base-image:latest\n</code></pre>"},{"location":"usage/#build-the-application-image-pip","title":"Build the application image (pip)","text":"<p>We will base the final application image on our custom base image. The base image build installed all the RPMs we will need, so the final phase can use network isolation again \ud83c\udf89. In order to support the network isolated build, we need to remember to <code>source</code> the environment file in the step that executes <code>pip install</code>. Because <code>osbs-client</code> comes from GitHub, the source code in <code>/src/atomic-reactor</code> has also been changed so that the dependencies are pointing to the cached versions.</p> <p>Containerfile:</p> <pre><code>FROM atomic-reactor-base-image:latest\n\nCOPY atomic-reactor/ /src/atomic-reactor\nWORKDIR /src/atomic-reactor\n\n# Need to source the hermeto.env file to set the environment variables\n# (in the same RUN instruction as the pip commands)\nRUN source /tmp/hermeto.env &amp;&amp; \\\n    # We're using network isolation =&gt; cannot build the cryptography package with Rust\n    # (it downloads Rust crates)\n    export CRYPTOGRAPHY_DONT_BUILD_RUST=1 &amp;&amp; \\\n    python3.8 -m pip install -U pip &amp;&amp; \\\n    python3.8 -m pip install --use-pep517 -r requirements.txt &amp;&amp; \\\n    python3.8 -m pip install --use-pep517 .\n\nCMD [\"python3.8\", \"-m\", \"atomic_reactor.cli.main\", \"--help\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag atomic-reactor\n</code></pre>"},{"location":"usage/#example-npm","title":"Example: npm","text":"<p>Let's build simple npm project sample-nodejs-app. Get the repo if you want to try for yourself:</p> <pre><code>git clone https://github.com/cachito-testing/sample-nodejs-app.git\n</code></pre>"},{"location":"usage/#pre-fetch-dependencies-npm","title":"Pre-fetch dependencies (npm)","text":"<p>The steps for pre-fetching the dependencies is similar to before, but this time we will use the <code>npm</code> package manager type. The default behavior path of <code>.</code> is assumed.</p> <p>See the npm documentation for more details about running Hermeto for pre-fetching npm dependencies.</p> <pre><code>hermeto fetch-deps --source ./sample-nodejs-app --output ./hermeto-output '{\"type\": \"npm\"}'\n</code></pre>"},{"location":"usage/#generate-environment-variables-npm","title":"Generate environment variables (npm)","text":"<p>Next, we need to generate the environment file, so we can provide environment variables to the <code>npm install</code> command.</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <p>Currently, Hermeto does not require any environment variables for the npm package manager, but this might change in the future.</p>"},{"location":"usage/#inject-project-files-npm","title":"Inject project files (npm)","text":"<p>In order to be able to install npm dependencies in a hermetic environment, we need to perform the injection to change the remote dependencies to instead point to the local file system.</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre> <p>We can look at the <code>git diff</code> to see what the package remapping looks like. As an example,</p> <pre><code>diff --git a/package-lock.json b/package-lock.json\n-      \"resolved\": \"https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz\",\n+      \"resolved\": \"file:///tmp/hermeto-output/deps/npm/accepts-1.3.8.tgz\",\n</code></pre>"},{"location":"usage/#build-the-application-image-npm","title":"Build the application image (npm)","text":"<p>We will base the final application image on <code>node:18</code> base image. The base image build has <code>npm</code> pre-installed, so the final phase can use network isolation \ud83c\udf89.</p> <pre><code>FROM node:18\n\nCOPY sample-nodejs-app/ /src/sample-nodejs-app\nWORKDIR /src/sample-nodejs-app\n\n# Run npm install command and list installed packages\nRUN . /tmp/hermeto.env &amp;&amp; npm i &amp;&amp; npm ls\n\nEXPOSE 9000\n\nCMD [\"node\", \"index.js\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag sample-nodejs-app\n</code></pre>"},{"location":"usage/#example-yarn","title":"Example: yarn","text":"<p>For the Yarn example let's use the same sample Node.js project, but this time modified to use Yarn as the package manager. Get the repo if you want to try for yourself:</p> <pre><code>git clone -b yarn https://github.com/cachito-testing/sample-nodejs-app.git\n</code></pre>"},{"location":"usage/#pre-fetch-dependencies-yarn","title":"Pre-fetch dependencies (yarn)","text":"<p>The steps for pre-fetching the dependencies are very similar to the previous examples, this time using the Yarn package manager. Like with the previous examples the default path for the package we assume is <code>.</code>.</p> <p>See the Yarn documentation for more details about running Hermeto for pre-fetching yarn dependencies.</p> <pre><code>hermeto fetch-deps --source ./sample-yarn-app --output ./hermeto-output '{\"type\": \"yarn\"}'\n</code></pre> <p>OR more simply (without the need of a JSON formatted argument) just </p> <pre><code>hermeto fetch-deps --source ./sample-yarn-app --output ./hermeto-output yarn\n</code></pre>"},{"location":"usage/#generate-environment-variables-yarn","title":"Generate environment variables (yarn)","text":"<p>There are a few environment variables we'll have to set for Yarn during the hermetic build, so we need to generate an environment file.</p> <pre><code>$ hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n$ cat ./hermeto.env\nexport YARN_ENABLE_GLOBAL_CACHE=false\nexport YARN_ENABLE_IMMUTABLE_CACHE=false\nexport YARN_ENABLE_MIRROR=true\nexport YARN_GLOBAL_FOLDER=/tmp/hermeto-output/deps/yarn\n</code></pre>"},{"location":"usage/#inject-project-files-yarn","title":"Inject project files (yarn)","text":"<p>Like the <code>gomod</code> package manager Yarn does not currently need to modify any content in the source directory for the cached dependencies to be used in a hermetic build, however that might change in the future.</p>"},{"location":"usage/#build-the-application-image-yarn","title":"Build the application image (yarn)","text":"<p>Yarn is installed using a Node.js tool called Corepack which has been shipped by Node.js by default since v16.9.0 and v14.19.0. Therefore, we'll use the <code>node:18</code> base image in our example which definitely has Corepack and we can start using Yarn right away.</p> <pre><code>FROM node:18\n\nCOPY sample-yarn-app/ /src/sample-yarn-app\nWORKDIR /src/sample-yarn-app\n\n# Run yarn install command and list installed packages\nRUN . /tmp/hermeto.env &amp;&amp; yarn install\n\nEXPOSE 9000\n\nCMD [\"yarn\", \"run\", \"start\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag sample-nodejs-app\n</code></pre>"},{"location":"usage/#example-generic-fetcher","title":"Example: generic fetcher","text":"<p>Generic fetcher is a package manager that can fetch arbitrary files. Let's build a sample container image that would be inconvenient to build hermetically otherwise. This image will provide OWASP Dependency check tool, which is available to install from GitHub releases page. Get the repo if you want to try for yourself:</p> <pre><code>git clone -b sample-app https://github.com/cachito-testing/cachi2-generic.git\n</code></pre>"},{"location":"usage/#pre-fetch-dependencies-generic-fetcher","title":"Pre-fetch dependencies (generic fetcher)","text":"<p>In order to retrieve the archive with the tool, either a <code>artifacts.lock.yaml</code> needs to be in the repository, or an absolute path needs to be supplied in the JSON input, pointing to a lockfile. You can find a sample lockfile below. It is identical to the one found in the sample repository. A lockfile for the generic fetcher must contain a <code>metadata</code> header and a list of artifacts, where each artifact is represented as a pair of URL and a checksum string in the format of <code>\"algorithm:checksum\"</code>. Optionally, you can also specify an output <code>filename</code> for the artifact. If not specified, it will be derived from the url. </p> <pre><code>---\nmetadata:\n  version: \"1.0\"\nartifacts:\n  - download_url: \"https://github.com/jeremylong/DependencyCheck/releases/download/v11.1.0/dependency-check-11.1.0-release.zip\"\n    checksum: \"sha256:c5b5b9e592682b700e17c28f489fe50644ef54370edeb2c53d18b70824de1e22\"\n    filename: \"dependency-check.zip\"\n</code></pre> <p>As with other examples, the command to fetch dependencies is very similar. The default path is assumed to be <code>.</code>.</p> <pre><code>hermeto fetch-deps --source ./hermeto-generic --output ./hermeto-output generic\n</code></pre>"},{"location":"usage/#build-the-application-image-generic-fetcher","title":"Build the application image (generic fetcher)","text":"<p>We'll use the <code>ibmjava:11-jdk</code> as base image because it already has java pre-installed. During the build, the downloaded release will be extracted and modified to have execute rights.</p> <pre><code>FROM ibmjava:11-jdk\n\nWORKDIR /tmp\n\n# use jar to unzip file in order to avoid having to install more depependencies\nRUN jar -xvf hermeto-output/deps/generic/dependency-check.zip\n\nRUN chmod +x dependency-check/bin/dependency-check.sh\n\nENTRYPOINT [\"/tmp/dependency-check/bin/dependency-check.sh\", \"--version\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data.</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --network none \\\n  --tag sample-generic-app\n</code></pre>"},{"location":"yarn/","title":"yarn","text":"<p>https://yarnpkg.com/</p> <ul> <li>Hermeto's Yarn support scope<ul> <li>Supported Yarn versions</li> <li>Supported Yarn protocols/locators</li> <li>Dealing with .yarnrc.yml</li> <li>Dealing with Yarn Zero-Installs</li> <li>Dealing with plugins</li> </ul> </li> <li>Specifying packages to process<ul> <li>Controlling Yarn's behavior</li> <li>Downloading dependencies</li> <li>Known pitfalls</li> </ul> </li> <li>Using fetched dependencies<ul> <li>Building your project using the pre-fetched Yarn dependency cache</li> </ul> </li> </ul>"},{"location":"yarn/#hermetos-yarn-support-scope","title":"Hermeto's Yarn support scope","text":""},{"location":"yarn/#supported-yarn-versions","title":"Supported Yarn versions","text":"<p>Hermeto currently supports Yarn versions 1, 3 and 4. Version 1 is referred to as \"Yarn Classic\" and is covered in yarn_classic.md. This document describes Yarn v3 and v4 support.</p>"},{"location":"yarn/#supported-yarn-protocolslocators","title":"Supported Yarn protocols/locators","text":"<p>Hermeto currently supports all standard Yarn protocols except for: - Exec - Git/GitHub</p> <p>Due to the nature of how the two protocols above work, mainly related to potentially executing arbitrary code, adding support for them with future releases of Hermeto is unlikely. For further details on Yarn protocols and their practical <code>package.json</code> examples, please head to the official Yarn documentation on protocols linked earlier in this section.</p>"},{"location":"yarn/#dealing-with-yarnrcyml","title":"Dealing with .yarnrc.yml","text":"<p>Hermeto parses the project's <code>.yarnrc.yml</code> file and analyzes configuration settings. Before hermeto proceeds with the actual dependency fetching, it verifies whether all configuration settings that set a path to a resource don't point outside of the source repository, so in order to avoid any issues reported by Hermeto in this regard make sure all your project resource references are bound by the repository. Part of the analysis of the repository's <code>.yarnrc.yml</code> file is detection of plugin usage which is further explained in Dealing with plugins.</p>"},{"location":"yarn/#dealing-with-yarn-zero-installs","title":"Dealing with Yarn Zero-Installs","text":"<p>Yarn's PnP Zero-Installs are unsupported due to the potentially unplugged dependencies checked into the repository which simply make it impossible for the Yarn cache to be checked for integrity using Yarn's standard tooling (i.e. <code>yarn install --check-cache</code>).</p> <p>Note: the same applies to dealing with the <code>node_modules</code> top level directory which, if checked into the repository, can also serve the Zero-Install purpose. If you need further information on which dependency linking mode is used, have a look at the nodeLinker and on the PnP approach in general.</p> <p>Also note that we may reconsider our initial decision when it comes to Zero-Installs provided the input repository doesn't rely on any dependencies which may include install scripts leading to their unpacking in a form of <code>.yarn/unplugged</code> entries.</p>"},{"location":"yarn/#dealing-with-plugins","title":"Dealing with plugins","text":"<p>Due to the nature of plugins (which can potentially execute arbitrary code, by e.g. adding new protocol resolvers), all plugins except for the official ones (see \"Default Plugins\" here) one are disabled during the dependency prefetch stage to ensure no other changes apart from downloading dependencies took action.</p> <p>For Yarn v3, even the official plugins are disabled, with the exception of exec.</p> <p>Note: hermeto doesn't taint your project files, so any plugins you set will be enabled normally in your build environment, the only problem that can arise is if any of your specified plugins adds a new protocol which hermeto doesn't know about in which case the dependency pre-fetch stage will fail with an error.</p>"},{"location":"yarn/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>A package is a file or directory that is described by a package.json file (also called a manifest).</p> <p>Hermeto <code>fetch-deps</code> shell command:</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>JSON input:</p> <pre><code>{\n  // \"yarn\" tells Hermeto to process Yarn packages\n  \"type\": \"yarn\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n}\n</code></pre> <p>or more simply by just invoking: <code>hermeto fetch-deps yarn</code></p> <p>For complete example of how to pre-fetch dependencies, see Pre-fetch dependencies.</p>"},{"location":"yarn/#controlling-yarns-behavior","title":"Controlling Yarn's behavior","text":"<p>Hermeto instructs Yarn to download dependencies explicitly declared in <code>package.json</code>. The dependencies are then further managed in a <code>yarn.lock</code> file that Yarn CLI manages automatically and creates it if missing. However, Hermeto will refuse to process your repository if the file is missing, so be sure to check that file into the repository. Also make sure that the file is up to date for which you can use yarn install.</p>"},{"location":"yarn/#downloading-dependencies","title":"Downloading dependencies","text":"<p>If Yarn is configured to operate in the PnP mode (the default in Yarn v3 or v4) Yarn will store all dependencies as ZIP archives.</p> <p>Once the source repository analysis and verification described in the earlier sections of this document has been completed, then it's essentially just a matter of hermeto internally invoking <code>yarn install --mode=skip-build</code> to fetch all dependencies (including transitive dependencies).</p>"},{"location":"yarn/#known-pitfalls","title":"Known pitfalls","text":"<p>If your repository isn't in a pristine state (i.e. you tried to run <code>yarn install</code> previously on your own without Hermeto) what may happen is that Hermeto will assume the repository makes use of Zero-Installs. The workaround here is simple, just run <code>yarn cache clean</code> and hermeto will then process your repository as normal.</p>"},{"location":"yarn/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See also usage.md for a complete example of Hermeto usage.</p> <p>Hermeto downloads the Yarn dependencies into the <code>deps/yarn/</code> subpath of the output directory (see the snippet below).</p> <pre><code>hermeto-output/deps/yarn\n\u2514\u2500\u2500 cache\n    \u251c\u2500\u2500 abbrev-npm-1.1.1-3659247eab-8.zip\n    \u251c\u2500\u2500 agent-base-npm-6.0.2-428f325a93-8.zip\n    \u251c\u2500\u2500 agentkeepalive-npm-4.3.0-ac3d8e6807-8.zip\n    \u251c\u2500\u2500 aggregate-error-npm-3.1.0-415a406f4e-8.zip\n    \u251c\u2500\u2500 ansi-regex-npm-3.0.1-01f44078a3-8.zip\n...\n</code></pre>"},{"location":"yarn/#building-your-project-using-the-pre-fetched-yarn-dependency-cache","title":"Building your project using the pre-fetched Yarn dependency cache","text":"<p>In order to use the hermeto pre-fetched Yarn dependency cache obtained from the previous step several environment variables need to be set in your build environment. See Generate environment variables for more details on how these can be generated by hermeto automatically in a form of a environment file that can sourced as part of your container build recipe. Here's a snippet of the most important variables hermeto needs to be set in the build environment along with explanation:</p> <pre><code># Point Yarn to our pre-populated global cache\nYARN_GLOBAL_FOLDER=&lt;hermeto_output_dir&gt;/deps/yarn\n\n# Yarn must not rely solely on the global cache (the pre-fetched one) because it'll likely only be\n# available (i.e. mounted) during the (container) build time, but not runtime. We specifically want\n# Yarn to copy those dependencies from the global cache to the project's local cache\nYARN_ENABLE_GLOBAL_CACHE=false\n\n# Must be set to true, otherwise Yarn will not make use of the pre-populated global cache we're\n# pointing it at with YARN_GLOBAL_FOLDER at build time.\nYARN_ENABLE_MIRROR=true\n\n# Must be false otherwise 'yarn install' will fail to populate the project's local cache (pointed\n# to by the 'cacheFolder' setting) from the global cache (the pre-fetched one).\nYARN_ENABLE_IMMUTABLE_CACHE=false\n</code></pre>"},{"location":"yarn_classic/","title":"Yarn Classic (Yarn v1)","text":"<p>https://classic.yarnpkg.com/</p> <ul> <li>Overview</li> <li>Supported dependencies types</li> <li>Fetching dependencies for Yarn Classic projects</li> <li>Prerequisites for an offline build</li> <li>Limitations and caveats</li> <li>Yarn version specified anywhere in the package will be ignored by prefetch</li> <li>Yarn Zero-Installs are not supported</li> <li>Handling of yarn-specific config files</li> <li>Variables set during fetch phase</li> </ul> <p>This document outlines the differences between Yarn Classic and Yarn support. Please refer to Yarn documentation for common aspects of PMs behavior. <code>Yarn</code> and <code>Yarn Classic</code> will be used interchangeably in this document, any other versions of Yarn will be explicitly mentioned.</p>"},{"location":"yarn_classic/#overview","title":"Overview","text":"<p>Yarn Classic package manager (PM) relies on Yarn Classic being installed on the system where Hermeto is run. If requested to process a package with Yarn Classic PM it will check for yarn version and will refuse to proceed if necessary version is missing. Yarn itself is used by Hermeto under the hood to organize package processing with some tweaks to ensure that the packages are prepared to be built in isolation.</p> <p>Hermeto expects to find well-formed <code>package.json</code> and <code>yarn.lock</code> checked in into a repository and will not continue if any of the files are missing. <code>yarn.lock</code> must be up to date and all file or path dependencies must be confined to the project repository.</p> <p>Prefetching dependencies for Yarn in Hermeto is done using Yarn's offline mirror feature. The project must be configured to use the offline mirror feature. Refer to Prerequisites for an offline build for details.</p>"},{"location":"yarn_classic/#supported-dependencies-types","title":"Supported dependencies types","text":"<p>Yarn Classic PM is capable of processing the following types of dependencies:  * packages from registries;  * packages from git repos;  * packages from http/https URLs;  * packages from local paths;  * local workspace packages;  * local link packages.</p>"},{"location":"yarn_classic/#fetching-dependencies-for-yarn-classic-projects","title":"Fetching dependencies for Yarn Classic projects","text":"<p>The process of fetching dependencies for Yarn Classic is similar to that for any other package manager. The name of package manager is <code>yarn_classic</code>, and it does not expect any additional arguments.</p> <p>Hermeto <code>fetch-deps</code> shell command:</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where JSON input is:</p> <pre><code>{\n  // \"yarn_classic\" tells Hermeto to process Yarn packages\n  \"type\": \"yarn_classic\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n}\n</code></pre> <p>or more simply by just invoking: <code>hermeto fetch-deps yarn_classic</code></p> <p>For complete example of how to pre-fetch dependencies, see Pre-fetch dependencies.</p>"},{"location":"yarn_classic/#prerequisites-for-an-offline-build","title":"Prerequisites for an offline build","text":"<p>A project that is to be hermetically built must be configured to use an offline mirror.  This means that Yarn will store compressed archives on the file system in a mirror directory and will install them from there later without network access.</p> <p>The actual build process will use Yarn directly, thus a project must be configured to use offline mirror either by providing a <code>.yarnrc</code> file or by setting up several environment variables. In case when <code>.yarnrc</code> is preferred it must contain the following lines:</p> <pre><code>yarn-offline-mirror &lt;absolute path to the request output directory&gt;\nyarn-offline-mirror-pruning false\n</code></pre> <p>It can be either directly written to or <code>yarn config</code> could be used:</p> <pre><code>$ yarn config set yarn-offline-mirror &lt;absolute path to the request output directory&gt;\n$ yarn config set yarn-offline-mirror-pruning false\n</code></pre> <p>In case when environment variables approach is preferred the following variables must be set:</p> <pre><code>YARN_YARN_OFFLINE_MIRROR=&lt;absolute path to the request output directory&gt;\nYARN_YARN_OFFLINE_MIRROR_PRUNING=false\n</code></pre> <p>Hermeto provides a helper that generates these variables and places them into a file. Sourcing this file is enough to set them.</p>"},{"location":"yarn_classic/#limitations-and-caveats","title":"Limitations and caveats","text":""},{"location":"yarn_classic/#yarn-version-specified-anywhere-in-the-package-will-be-ignored-by-prefetch","title":"Yarn version specified anywhere in the package will be ignored by prefetch","text":"<p>Unlike in the case of Yarn v3 Hermeto will used whichever version is available system-wide on a system where a package is prefetched. In most practical cases this will default to the latest stable version of Yarn Classic (which is not under active development anymore).</p>"},{"location":"yarn_classic/#yarn-zero-installs-are-not-supported","title":"Yarn Zero-Installs are not supported","text":"<p>Yarn Classic's Plug'n'Play feature is not supported. Any package that uses it will be rejected. For further details please refer to [Yarn v3 documentation].</p>"},{"location":"yarn_classic/#handling-of-yarn-specific-config-files","title":"Handling of yarn-specific config files","text":"<p>Yarn Classic allows a user to provide additional configuration via .yarnrc and .npmrc.  Hermeto ignores these settings during prefetch phase. However a <code>.yarnrc</code> could be used for setting up an offline mirror (Prerequisites for an offline build).  These settings will be applied during a build phase.</p>"},{"location":"yarn_classic/#variables-set-during-fetch-phase","title":"Variables set during fetch phase","text":"<p>The following variables are set for Yarn in the fetch phase:</p> <ul> <li><code>COREPACK_ENABLE_DOWNLOAD_PROMPT</code> is set to \"0\" which prevents    Corepack from showing the URL when it needs to download software;</li> <li><code>COREPACK_ENABLE_PROJECT_SPEC</code> is set to \"0\" which prevents    Corepack from checking if the package manager corresponds to the one    defined for the current project;</li> <li><code>YARN_IGNORE_PATH</code> is set to \"true\" which ignores any Yarn version specified by a user and    uses Corepack's version instead;</li> <li><code>YARN_IGNORE_SCRIPTS</code>: is set to \"true\" which prevents execution of any scripts defined in    <code>package.json</code> or in any dependency;</li> <li><code>YARN_YARN_OFFLINE_MIRROR</code> is set to point to <code>deps/yarn-classic</code> which is relative to    output directory and will hold fetched dependencies;</li> <li><code>YARN_YARN_OFFLINE_MIRROR_PRUNING</code> is set to \"false\" which prevents Yarn from attempting to    ensure that dependencies are up to date.</li> </ul> <p>Once fetch phase is completed Hermeto will need to generate an environment file with variables pointing to the mirror and instructing Yarn not to prune it:</p> <pre><code>YARN_YARN_OFFLINE_MIRROR=&lt;request output directory&gt;\nYARN_YARN_OFFLINE_MIRROR_PRUNING=false\n</code></pre> <p>Sourcing this file will prime Yarn for an offline build.</p>"}]}